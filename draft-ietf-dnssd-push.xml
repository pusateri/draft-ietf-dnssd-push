<?xml version="1.0" encoding="UTF-8"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
    which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
    There has to be one entity for each item to be referenced.
    An alternate method (rfc include) is described in the references. -->

<!ENTITY RFC0768 SYSTEM  "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.0768.xml">
<!ENTITY RFC0793 SYSTEM  "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.0793.xml">
<!ENTITY RFC1034 SYSTEM  "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.1034.xml">
<!ENTITY RFC1035 SYSTEM  "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.1035.xml">
<!ENTITY RFC1123 SYSTEM  "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.1123.xml">
<!ENTITY RFC2119 SYSTEM  "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC2136 SYSTEM  "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2136.xml">
<!ENTITY RFC2181 SYSTEM  "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2181.xml">
<!ENTITY RFC2308 SYSTEM  "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2308.xml">
<!ENTITY RFC3123 SYSTEM  "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3123.xml">
<!ENTITY RFC2782 SYSTEM  "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2782.xml">
<!ENTITY RFC4287 SYSTEM  "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4287.xml">
<!ENTITY RFC4953 SYSTEM  "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4953.xml">
<!ENTITY RFC5077 SYSTEM  "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5077.xml">
<!ENTITY RFC6066 SYSTEM  "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6066.xml">
<!ENTITY RFC6281 SYSTEM  "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6281.xml">
<!ENTITY RFC6762 SYSTEM  "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6762.xml">
<!ENTITY RFC6763 SYSTEM  "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6763.xml">
<!ENTITY RFC6824 SYSTEM  "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6824.xml">
<!ENTITY RFC6886 SYSTEM  "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6886.xml">
<!ENTITY RFC6887 SYSTEM  "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6887.xml">
<!ENTITY RFC6895 SYSTEM  "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6895.xml">
<!ENTITY RFC7413 SYSTEM  "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7413.xml">
<!ENTITY RFC7525 SYSTEM  "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7525.xml">
<!ENTITY RFC7673 SYSTEM  "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7673.xml">
<!ENTITY RFC7719 SYSTEM  "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7719.xml">
<!ENTITY RFC7766 SYSTEM  "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7766.xml">
<!ENTITY RFC7858 SYSTEM  "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7858.xml">
<!ENTITY RFC8010 SYSTEM  "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8010.xml">
<!ENTITY RFC8011 SYSTEM  "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8011.xml">
<!ENTITY RFC8174 SYSTEM  "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml">
<!ENTITY RFC8310 SYSTEM  "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8310.xml">
<!ENTITY RFC8446 SYSTEM  "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8446.xml">
<!ENTITY RFC8490 SYSTEM  "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8490.xml">
<!ENTITY I-D.dukkipati-tcpm-tcp-loss-probe SYSTEM  "https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.dukkipati-tcpm-tcp-loss-probe.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs),
    please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
    (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space
    (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="std" docName="draft-ietf-dnssd-push-22" ipr="trust200902">
 <!-- category values: std, bcp, info, exp, and historic
    ipr values: trust200902, noModificationTrust200902, noDerivativesTrust200902,
       or pre5378Trust200902
    you can add the attributes updates="NNNN" and obsoletes="NNNN"
    they will automatically be output with "(if approved)" -->

 <!-- ***** FRONT MATTER ***** -->

 <front>
   <!-- The abbreviated title is used in the page header - it is only necessary if the
        full title is longer than 39 characters -->

   <title abbrev="DNS Push Notifications">DNS Push Notifications</title>

   <!-- add 'role="editor"' below for the editors if appropriate -->

   <!-- Another author who claims to be an editor -->

   <author fullname="Tom Pusateri" initials="T.J." surname="Pusateri">
     <organization>Unaffiliated</organization>

     <address>
       <postal>
         <street></street>
         <!-- Reorder these if your country does things differently -->
         <city>Raleigh</city>
         <region>NC</region>
         <code>27608</code>
         <country>USA</country>
       </postal>
       <phone>+1 919 867 1330</phone>
       <email>pusateri@bangj.com</email>
       <!-- uri and facsimile elements may also be added -->
     </address>
   </author>
   <author fullname="Stuart Cheshire" initials="S." surname="Cheshire">
     <organization>Apple Inc.</organization>

     <address>
       <postal>
         <street>One Apple Park Way</street>
         <!-- Reorder these if your country does things differently -->
         <city>Cupertino</city>
         <region>CA</region>
         <code>95014</code>
         <country>USA</country>
       </postal>
       <phone>+1 (408) 996-1010</phone>
       <email>cheshire@apple.com</email>
       <!-- uri and facsimile elements may also be added -->
     </address>
   </author>

   <date year='2019' month='July' day='8'/>

   <!-- If the month and year are both specified and are the current ones, xml2rfc will fill
        in the current day for you. If only the current year is specified, xml2rfc will fill
        in the current day and month for you. If the year is not the current one, it is
        necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the
        purpose of calculating the expiry date).  With drafts it is normally sufficient to
        specify just the year. -->

   <!-- Meta-data Declarations -->

   <area>DNSSD</area>

   <workgroup>Internet Engineering Task Force</workgroup>

   <!-- WG name at the upper left corner of the doc,
        IETF is fine for individual submissions.
        If this element is not present, the default is "Network Working Group",
        which is used by the RFC Editor as a nod to the history of the IETF. -->

   <keyword>dns update push notification</keyword>

   <!-- Keywords will be incorporated into HTML output
        files in a meta tag but they have no effect on text or nroff
        output. If you submit your draft to the RFC Editor, the
        keywords will be used for the search engine. -->

   <abstract>
     <t>The Domain Name System (DNS) was designed to return matching records
     efficiently for queries for data that are relatively static.
     When those records change frequently, DNS is still efficient at returning
     the updated results when polled, as long as the polling rate is not too high.
     But there exists no mechanism
     for a client to be asynchronously notified when these changes occur.
     This document defines a mechanism for a client to be notified
     of such changes to DNS records, called DNS Push Notifications.</t>
   </abstract>
 </front>

 <middle>
<?rfc needLines="14" ?>
   <section title="Introduction">

     <t>Domain Name System (DNS) records may be updated using <xref target="RFC2136">DNS Update</xref>.
     Other mechanisms such as a <xref target="DisProx">Discovery Proxy</xref> can also generate changes to a DNS zone.
     This document specifies a protocol for DNS clients to subscribe to receive asynchronous notifications of changes to RRsets of interest. It is immediately relevant in the case of <xref target="RFC6763">DNS Service Discovery</xref> but is not limited to that use case, and provides a general DNS mechanism for DNS record change notifications. Familiarity with the DNS protocol and DNS packet formats is assumed <xref target="RFC1034"/> <xref target="RFC1035"/> <xref target="RFC6895"/>.</t>

<?rfc needLines="7" ?>
     <section title="Requirements Language">
       <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
       "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY",
       and "OPTIONAL" in this document are to be interpreted as described
       in BCP&nbsp;14 <xref target="RFC2119"/> <xref target="RFC8174"/>
       when, and only when, they appear in all capitals, as shown here.
       These words may also appear in this document in lower case as
       plain English words, absent their normative meanings.</t>
<?rfc needLines="40" ?>
     </section>
   </section>

   <section title="Motivation">
     <t>As the domain name system continues to adapt to new uses and changes in deployment, polling has the potential to burden DNS servers at many levels throughout the network. Other network protocols have successfully deployed a publish/subscribe model following the <xref target="obs">Observer design pattern</xref>.
     <xref target="XEP0060">XMPP Publish-Subscribe</xref> and <xref target="RFC4287">Atom</xref> are examples. While DNS servers are generally highly tuned and capable of a high rate of query/response traffic, adding a publish/subscribe model for tracking changes to DNS records can deliver more timely notification of changes with reduced CPU usage and lower network traffic.</t>

     <t><xref target="RFC6762">Multicast DNS</xref> implementations always listen on a well known link-local IP multicast group address, and record changes are sent to that multicast group address for all group members to receive. Therefore, Multicast DNS already has asynchronous change notification capability. However, when <xref target="RFC6763">DNS Service Discovery</xref> is used across a wide area network using Unicast DNS (possibly facilitated via a <xref target="DisProx">Discovery Proxy</xref>) it would be beneficial to have an equivalent capability for Unicast DNS, to allow clients to learn about DNS record changes in a timely manner without polling.</t>

     <t>The <xref target="LLQ">DNS Long-Lived Queries (LLQ) mechanism</xref> is an existing deployed solution to provide asynchronous change notifications, used by Apple's <xref target="RFC6281">Back to My Mac</xref> service
     introduced in Mac OS X 10.5 Leopard in 2007.
     Back to My Mac was designed in an era when the data center operations staff asserted that it was impossible for a server to handle large numbers of mostly-idle TCP connections, so LLQ was defined as a UDP-based protocol, effectively replicating much of TCP's connection state management logic in user space, and creating its own poor imitations of existing TCP features like the three-way handshake, flow control, and reliability.</t>

     <t>This document builds on experience gained with the LLQ protocol, with an improved design.
     Instead of using UDP, this specification uses
     <xref target="RFC8490">DNS Stateful Operations (DSO)</xref>
     running over TLS over TCP,
     and therefore doesn't need to reinvent existing TCP functionality.
     Using TCP also gives long-lived low-traffic connections better longevity through NAT gateways
     without depending on the gateway to support
     <xref target="RFC6886">NAT Port Mapping Protocol (NAT-PMP)</xref> or
     <xref target="RFC6887">Port Control Protocol (PCP)</xref>, or
     resorting to excessive keepalive traffic.</t>

<?rfc needLines="9" ?>
   </section>

   <section title="Overview">
     <t>A DNS Push Notification client subscribes for Push Notifications for a particular RRset by connecting to the appropriate Push Notification server for that RRset, and sending DSO message(s) indicating the RRset(s) of interest. When the client loses interest in receiving further updates to these records, it unsubscribes.</t>

     <t>The DNS Push Notification server for a DNS zone is any server capable
     of generating the correct change notifications for a name.
     It may be a primary, secondary, or stealth name server <xref target="RFC7719"/>.</t>

     <t>The <spanx style="verb">_dns&nbhy;push&nbhy;tls._tcp.&lt;zone&gt;</spanx> SRV record for a
     zone MAY reference the same target host and port as that zone's
     <spanx style="verb">_dns&nbhy;update&nbhy;tls._tcp.&lt;zone&gt;</spanx> SRV record. When the same target host and port is offered for both DNS Updates and DNS Push Notifications, a client MAY use a single DSO session to that server for both DNS Updates and DNS Push Notification Subscriptions.
     DNS Updates and DNS Push Notifications may be handled on different ports on the same target host, in which case they are not considered to be the "same server" for the purposes of this specification, and communications with these two ports are handled independently.
     Supporting DNS Updates and DNS Push Notifications on the same server is OPTIONAL. A DNS Push Notification server is not required to support DNS Update.</t>


     <t>Standard DNS Queries MAY be sent over a DNS Push Notification (i.e., DSO)
   session.   For any zone for which the server is authoritative, it
   MUST respond authoritatively for queries for names falling within
   that zone (e.g., the <spanx style="verb">_dns&nbhy;push&nbhy;tls._tcp.&lt;zone&gt;</spanx> SRV
   record) both for normal DNS queries and for DNS Push Notification subscriptions.
   For names for which the server is acting as a recursive
   resolver, e.g., when the server is the local recursive resolver, for any query
   for which it supports DNS Push Notification subscriptions, it MUST also support
   standard queries.</t>

     <t>DNS Push Notifications impose less load on the responding server than rapid polling would, but Push Notifications do still have a cost, so DNS Push Notification clients MUST NOT recklessly create an excessive number of Push Notification subscriptions. Specifically:</t>

     <t>(a) A subscription should only be active when there is a valid reason to need live data (for example, an on-screen display is currently showing the results to the user) and the subscription SHOULD be cancelled as soon as the need for that data ends (for example, when the user dismisses that display). In the case of a device like a smartphone which, after some period of inactivity, goes to sleep or otherwise darkens its screen, it should cancel its subscriptions when darkening the screen (since the user cannot see any changes on the display anyway) and reinstate its subscriptions when re-awakening from display sleep.</t>

     <t>(b) A DNS Push Notification client SHOULD NOT routinely keep a DNS Push Notification subscription active 24 hours a day, 7 days a week, just to keep a list in memory up to date so that if the user does choose to bring up an on-screen display of that data, it can be displayed really fast. DNS Push Notifications are designed to be fast enough that there is no need to pre-load a "warm" list in memory just in case it might be needed later.</t>

     <t>Generally, as described in the <xref target="RFC8490">DNS Stateful Operations specification</xref>, a client must not keep a session to a server open indefinitely if it has no subscriptions (or other operations) active on that session. A client MAY close a session as soon as it becomes idle, and then if needed in the future, open a new session when required. Alternatively, a client MAY speculatively keep an idle session open for some time, subject to the constraint that it MUST NOT keep a session open that has been idle for more than the session's idle timeout (15 seconds by default) <xref target="RFC8490"/>.</t>
<?rfc needLines="20" ?>
   </section>

   <section title="Transport">
     <t>Other DNS operations like <xref target="RFC2136">DNS Update</xref> MAY use either User Datagram Protocol <xref target="RFC0768">(UDP)</xref> or Transmission Control Protocol <xref target="RFC0793">(TCP)</xref> as the transport protocol, in keeping with the historical precedent that DNS queries must first be sent over UDP <xref target="RFC1123"/>. This requirement to use UDP has subsequently been relaxed <xref target="RFC7766"/>.</t>

     <t>In keeping with the more recent precedent, DNS Push Notification is defined only for TCP.
     DNS Push Notification clients MUST use
     <xref target="RFC8490">DNS Stateful Operations</xref>
     running over TLS over TCP <xref target="RFC7858"/>.</t>

     <t>Connection setup over TCP ensures return reachability and alleviates concerns of state overload at the server which is a potential problem with connectionless protocols using spoofed source addresses. All subscribers are guaranteed to be reachable by the server by virtue of the TCP three-way handshake.
     Flooding attacks are possible with any protocol, and a benefit of TCP is that there are already established industry best practices to guard against SYN flooding and similar attacks <xref target="SYN"/> <xref target="RFC4953"/>.</t>

     <t>Use of TCP also allows DNS Push Notifications to take advantage of current and future developments in TCP, such as
     <xref target="RFC6824">Multipath TCP (MPTCP)</xref>,
     <xref target="RFC7413">TCP Fast Open (TFO)</xref>,
     <xref target="I-D.dukkipati-tcpm-tcp-loss-probe">Tail Loss Probe (TLP)</xref>, and so on.</t>

     <t>Transport Layer Security <xref target="RFC8446">(TLS)</xref> is well understood, and used by many application-layer protocols running over TCP. TLS is designed to prevent eavesdropping, tampering, and message forgery. TLS is REQUIRED for every connection between a client subscriber and server in this protocol specification. Additional security measures such as client authentication during TLS negotiation MAY also be employed to increase the trust relationship between client and server.</t>

<?rfc needLines="25" ?>
   </section>

   <section title="State Considerations">
     <t>Each DNS Push Notification server is capable of handling some finite number of Push Notification subscriptions. This number will vary from server to server and is based on physical machine characteristics, network bandwidth, and operating system resource allocation. After a client establishes a session to a DNS server, each subscription is individually accepted or rejected. Servers may employ various techniques to limit subscriptions to a manageable level. Correspondingly, the client is free to establish simultaneous sessions to alternate DNS servers that support DNS Push Notifications for the zone and distribute subscriptions at the client's discretion. In this way, both clients and servers can react to resource constraints.</t>
<?rfc needLines="35" ?>
   </section>

   <section title="Protocol Operation">
     <t>The DNS Push Notification protocol is a session-oriented protocol, and makes use of
     <xref target="RFC8490">DNS Stateful Operations (DSO)</xref>.</t>

     <t>For details of the DSO message format refer to the
     <xref target="RFC8490">DNS Stateful Oper-ations specification</xref>.
     Those details are not repeated here.</t>

     <t>DNS Push Notification clients and servers MUST support DSO.
     A single server can support DNS Queries, DNS Updates, and DNS Push
     Notifications (using DSO) on the same TCP port.</t>

     <t>A DNS Push Notification exchange begins with the client discovering the appropriate server,
     using the procedure described in <xref target="discovery"/>, and then making a TLS/TCP connection to it.</t>

     <t>A typical DNS Push Notification client will immediately issue a DSO
     Keepalive operation to request a session timeout and/or keepalive interval
     longer than the the 15-second default values, but this is not required.
     A DNS Push Notification client MAY issue other requests on the
     session first, and only issue a DSO Keepalive
     operation later if it determines that to be necessary.
     Sending either a DSO Keepalive operation or a Push Notification
     subscription request over the TLS/TCP connection to the server signals the
     client's support of DSO and serves to establish a DSO session.</t>

     <t>In accordance with the current set of active subscriptions,
     the server sends relevant asynchronous Push Notifications to
     the client. Note that a client MUST be prepared to receive
     (and silently ignore) Push Notifications for subscriptions it
     has previously removed, since there is no way to prevent the
     situation where a Push Notification is in flight from server
     to client while the client's UNSUBSCRIBE message cancelling
     that subscription is simultaneously in flight from client to
     server.</t>

<?rfc needLines="30" ?>
      <section title="Discovery" anchor="discovery">
        <t>The first step in establishing a DNS Push Notification subscription is to discover an appropriate DNS server that supports DNS Push Notifications for the desired zone.</t>

        <t>The client begins by opening a DSO Session to its normal configured
        DNS recursive resolver and requesting a Push Notification subscription.
        This connection is made to TCP port 853, the default port for
        <xref target="RFC7858">DNS-over-TLS</xref>.
        If the request for a Push Notification subscription is successful,
        and the recursive resolver doesn't already have an active subscription for that name, type, and class,
        then the recursive resolver will make a corresponding
        Push Notification subscription on the client's behalf.
        Results received are relayed to the client.
        This is closely analogous to how a client sends a normal DNS
        query to its configured DNS recursive resolver which,
        if it doesn't already have appropriate answer(s) in its cache,
        issues an upstream query to satisfy the request.</t>

        <t>In many contexts, the recursive resolver will be able to handle
        Push Notifications for all names that the client may need to follow.
        Use of VPN tunnels and split-view DNS can create some additional complexity in the client software here;
        the techniques to handle VPN tunnels and split-view DNS for DNS Push Notifications are the
        same as those already used to handle this for normal DNS queries.</t>

        <t>If the recursive resolver
        does not support DNS over TLS, or
        supports DNS over TLS but is not listening on TCP port 853, or
        supports DNS over TLS on TCP port 853 but does not support DSO on that port,
        then the DSO Session session establishment will fail <xref target="RFC8490"/>.</t>

        <t>If the recursive resolver does support DSO but not Push Notification
        subscriptions, then it will return the DSO error code, DSOTYPENI (11).</t>

        <t>In some cases, the recursive resolver may support DSO and Push
        Notification subscriptions, but may not be able
        to subscribe for Push Notifications for a particular name.
        In this case, the recursive resolver should return
        SERVFAIL to the client. This includes being unable
        to establish a connection
        to the zone's DNS Push Notification server or establishing
        a connection but receiving a non success response code.
        In some cases, where the client has a pre-established trust
        relationship with the owner of the zone (that is not handled
        via the usual mechanisms for VPN software) the client may
        handle these failures by contacting the zone's DNS Push server
        directly.</t>

        <t>In any of the cases described above where the client
        fails to establish a DNS Push Notification subscription via its
        configured recursive resolver, the client should proceed to discover
        the appropriate server for direct communication.  The client MUST
        also determine which TCP port on the server is listening for
        connections, which need not be (and often is not) the typical TCP
        port 53 used for conventional DNS, or TCP port 853 used for DNS 
        over TLS.</t>

        <t>The discovery algorithm described here is an iterative algorithm,
        which starts with the full name of the record to which the
        client wishes to subscribe. Successive SOA queries are then
        issued, trimming one label each time, until
        the closest enclosing authoritative server is discovered.
        There is also an optimization to enable the client to
        take a "short cut" directly to the SOA record of
        the closest enclosing authoritative server in many cases.</t>

        <t>
          <list style="numbers">
            <t>The client begins the discovery by sending a DNS query to its local resolver, with record type
            <xref target="RFC1035">SOA</xref> for the record name to which it wishes to subscribe.
            As an example, suppose the client wishes to subscribe to PTR records
            with the name _ipp._tcp.headoffice.example.com
            (to discover Internet Printing Protocol (IPP) printers <xref target="RFC8010"/> <xref target="RFC8011"/>
            being advertised in the head office of Example Company.).
            The client begins by sending an SOA query for _ipp._tcp.headoffice.example.com to the local recursive resolver.
            The goal is to determine the server authoritative for the name _ipp._tcp.headoffice.example.com.
            The closest enclosing DNS zone containing the name _ipp._tcp.headoffice.example.com could be example.com,
            or headoffice.example.com, or _tcp.headoffice.example.com, or even _ipp._tcp.headoffice.example.com.
            The client does not know in advance where the closest enclosing zone cut occurs,
            which is why it uses the iterative procedure described here to discover this information.</t>

            <t>If the requested SOA record exists, it will be returned in the Answer section with a NOERROR response code, and
            the client has succeeded in discovering the information it needs.
            <vspace />
            (This language is not placing any new requirements on DNS recursive resolvers.
            This text merely describes the existing operation of the DNS protocol
            <xref target="RFC1034"/> <xref target="RFC1035"/>.)</t>

            <t>If the requested SOA record does not exist, the client will get back a NOERROR/NODATA response or an NXDOMAIN/Name Error response.
            In either case, the local resolver would normally include the SOA record for the closest enclosing zone of the requested name in the Authority Section.
            If the SOA record is received in the Authority Section, then
            the client has succeeded in discovering the information it needs.
            <vspace />
            (This language is not placing any new requirements on DNS recursive resolvers.
            This text merely describes the existing operation of the DNS protocol
            regarding negative responses <xref target="RFC2308"/>.)</t>

            <t>If the client receives a response containing no SOA record,
            then it proceeds with the iterative approach.
            The client strips the leading label from the current query name,
            and if the resulting name has at least two labels in it,
            the client sends an SOA query for that new name,
            and processing continues at step 2 above,
            repeating the iterative search until either an SOA is received,
            or the query name consists of a single label, i.e., a Top Level Domain (TLD).
            In the case of a single-label (TLD), this is a network configuration error,
            which should not happen, and the client gives up.
            The client may retry the operation at a later time, of the client's choosing,
            such after a change in network attachment.</t>

            <t>Once the SOA is known (either by virtue of being seen in the Answer Section, or in the Authority Section), the client sends a DNS query with type <xref target="RFC2782">SRV</xref> for the record name
            <spanx style="verb">_dns&nbhy;push&nbhy;tls._tcp.&lt;zone&gt;</spanx>, where &lt;zone&gt; is the owner name of the discovered SOA record.</t>

            <t>If the zone in question is set up to offer DNS Push Notifications then this SRV record MUST exist.
            (If this SRV record does not exist then the zone is not correctly
            configured for DNS Push Notifications as specified in this document.)
            The SRV <spanx style="verb">target</spanx> contains the name of the server providing DNS Push Notifications for the zone. The port number on which to contact the server is in the SRV record <spanx style="verb">port</spanx> field. The address(es) of the target host MAY be included in the Additional Section, however, the address records SHOULD be authenticated before use as described below in <xref target="tls_name_auth"/> and in
            <xref target="RFC7673">the specification for using DANE TLSA Records with SRV Records</xref>, if applicable.</t>

            <t anchor="SRV">More than one SRV record may be returned. In this case, the <spanx style="verb">priority</spanx> and <spanx style="verb">weight</spanx> values in the returned SRV records are used to determine the order in which to contact the servers for subscription requests. As described in <xref target="RFC2782">the SRV specification</xref>, the server with the lowest <spanx style="verb">priority</spanx> is first contacted. If more than one server has the same <spanx style="verb">priority</spanx>, the <spanx style="verb">weight</spanx> indicates the weighted probability that the client should contact that server. Higher weights have higher probabilities of being selected.
            If a server is not willing to accept a subscription request,
            or is not reachable within a reasonable time, as determined by the client,
            then a subsequent server is to be contacted.</t>

          </list>
        </t>

        <t>Each time a client makes a new DNS Push Notification subscription session, it SHOULD repeat the discovery process in order to determine the preferred DNS server for subscriptions at that time. However, the client device MUST respect the DNS TTL values on records it receives, and store them in its local cache with this lifetime. This means that, as long as the DNS TTL values on the authoritative records are set to reasonable values, repeated application of this discovery process can be completed nearly instantaneously by the client, using only locally-stored cached data.</t>

<?rfc needLines="48" ?>
     </section>

     <section title="DNS Push Notification SUBSCRIBE" anchor="subscribe">
       <t>After connecting, and requesting a longer idle timeout and/or
       keepalive interval if necessary, a DNS Push Notification client<vspace />
       then indicates its desire to receive DNS Push Notifications for<vspace />
       a given domain name by sending a SUBSCRIBE request to the server.<vspace />
       A SUBSCRIBE request is encoded in a DSO message <xref target="RFC8490"/>.<vspace />
       This specification defines a primary DSO TLV for DNS Push Notification SUBSCRIBE Requests (tentatively DSO Type Code 0x40).</t>

       <t>DSO messages with the SUBSCRIBE TLV as the Primary TLV are permitted in TLS early data,
       provided that the precautions described in <xref target="early_data"/> are followed.</t>

       <t>The entity that initiates a SUBSCRIBE request is by definition the client. A server MUST NOT send a SUBSCRIBE request over an existing session from a client. If a server does send a SUBSCRIBE request over a DSO session initiated by a client, this is a fatal error and the client should immediately abort the connection with a TLS close_notify alert
       (see Section 6.1 of the TLS 1.3 specification <xref target="RFC8446"/>).
       After sending the TLS close_notify alert
       the client MUST gracefully close the underlying connection using a TCP FIN,
       so that the TLS close_notify is reliably delivered.
       The mechanisms for gracefully closing a TCP connection with a TCP FIN vary depending on the networking API.
       For example, in the BSD Sockets API, sending a TCP FIN is achieved by calling "shutdown(s,SHUT_WR)"
       and keeping the socket open until all remaining data has been read from it.</t>

       <section title="SUBSCRIBE Request">
         <t>A SUBSCRIBE request begins with the standard
         <xref target="RFC8490">DSO 12-byte header</xref>, followed by the SUBSCRIBE primary TLV.
         A SUBSCRIBE request message is illustrated in <xref target="subscribe_req"/>.</t>

         <t>The MESSAGE ID field MUST be set to a unique value, that the client is not using for any other active operation on this DSO session. For the purposes here, a MESSAGE ID is in use on this session if the client has used it in a request for which it has not yet received a response, or if the client has used it for a subscription which it has not yet cancelled using UNSUBSCRIBE. In the SUBSCRIBE response the server MUST echo back the MESSAGE ID value unchanged.</t>

         <t>The other header fields MUST be set as described in the
         <xref target="RFC8490">DSO spec-ification</xref>.
         The DNS OPCODE field contains the OPCODE value for DNS Stateful Operations (6).
         The four count fields MUST be zero, and the corresponding four sections MUST be empty (i.e., absent).</t>

         <t>The DSO-TYPE is SUBSCRIBE (tentatively 0x40).</t>

         <t>The DSO-LENGTH is the length of the DSO-DATA that follows, which specifies
         the name, type, and class of the record(s) being sought.</t>

         <figure align="center" anchor="subscribe_req" title="SUBSCRIBE Request"><artwork align="center"><![CDATA[
                                1  1  1  1  1  1
  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+  \
|                  MESSAGE ID                   |   \
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    |
|QR| OPCODE(6) |         Z          |   RCODE   |    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    |
|             QDCOUNT (MUST BE ZERO)            |    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+     > HEADER
|             ANCOUNT (MUST BE ZERO)            |    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    |
|             NSCOUNT (MUST BE ZERO)            |    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    |
|             ARCOUNT (MUST BE ZERO)            |   /
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+  /
|    DSO-TYPE = SUBSCRIBE (tentatively 0x40)    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|   DSO-LENGTH (number of octets in DSO-DATA)   |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+  \
|                                               |   \
\                     NAME                      \    |
\                                               \    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+     > DSO-DATA
|                     TYPE                      |    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    |
|                     CLASS                     |   /
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+  /]]></artwork></figure>

         <t>The DSO-DATA for a SUBSCRIBE request MUST contain exactly one NAME, TYPE, and CLASS.
         Since SUBSCRIBE requests are sent over TCP, multiple SUBSCRIBE DSO request messages
         can be concatenated in a single TCP stream and packed efficiently into TCP segments.</t>

         <t>If accepted, the subscription will stay in effect until the client cancels the subscription using UNSUBSCRIBE or until the DSO session between the client and the server is closed.</t>

         <t>SUBSCRIBE requests on a given session MUST be unique. A client MUST NOT send a SUBSCRIBE message that duplicates the NAME, TYPE and CLASS of an existing active subscription on that DSO session. For the purpose of this matching, the established DNS case-insensitivity for US-ASCII letters applies (e.g., "example.com" and "Example.com" are the same). If a server receives such a duplicate SUBSCRIBE message this is a fatal error and the server MUST immediately terminate the connection with a TLS close_notify alert followed by a TCP FIN.</t>

         <t>DNS wildcarding is not supported. That is, a wildcard ("*") in a SUBSCRIBE message matches only a literal wildcard character ("*") in the zone, and nothing else.</t>

         <t>Aliasing is not supported. That is, a CNAME in a SUBSCRIBE message matches only a literal CNAME record in the zone, and no other records with the same owner name.</t>

         <t>A client may SUBSCRIBE to records that are unknown to the server at the time of the request (providing that the name falls within one of the zone(s) the server is responsible for) and this is not an error. The server MUST NOT return NXDOMAIN in this case. The server MUST accept these requests and send Push Notifications if and when matching records are found in the future.</t>

         <t>If neither TYPE nor CLASS are ANY (255) then this is a specific subscription to changes for the given NAME, TYPE and CLASS. If one or both of TYPE or CLASS are ANY (255) then this subscription matches any type and/or any class, as appropriate.</t>

<?rfc needLines="14" ?>
         <t>NOTE: A little-known quirk of DNS is that in DNS QUERY requests, QTYPE and QCLASS 255 mean "ANY" not "ALL". They indicate that the server should respond with ANY matching records of its choosing, not necessarily ALL matching records. This can lead to some surprising and unexpected results, where a query returns some valid answers but not all of them, and makes QTYPE=ANY queries less useful than people sometimes imagine.</t>

         <t>When used in conjunction with SUBSCRIBE, TYPE and CLASS 255 should be interpreted to mean "ALL", not "ANY". After accepting a subscription where one or both of TYPE or CLASS are 255, the server MUST send Push Notification Updates for ALL record changes that match the subscription, not just some of them.</t>
<?rfc needLines="48" ?>
       </section>

       <section title="SUBSCRIBE Response" anchor="subresp">

         <t>Each SUBSCRIBE request generates exactly one SUBSCRIBE response from the server.</t>

         <t>A SUBSCRIBE response begins with the standard
         <xref target="RFC8490">DSO 12-byte header</xref>.
         The QR bit in the header is set indicating it is a response.
         The header MAY be followed by one or more optional TLVs, such as a Retry Delay TLV.</t>

         <t>The MESSAGE ID field MUST echo the value given in the MESSAGE ID field of the SUBSCRIBE request.
         This is how the client knows which request is being responded to.</t>

         <t>A SUBSCRIBE response message MUST NOT include a SUBSCRIBE TLV.
         If a client receives a SUBSCRIBE response message containing a SUBSCRIBE TLV
         then the response message is processed but the SUBSCRIBE TLV MUST be silently ignored.</t>

         <t>A client MUST NOT send a SUBSCRIBE response.
         If a client does send a SUBSCRIBE message, with the QR bit set indicating that it is a response,
         this is a fatal error and the server should immediately abort the connection with a TLS close_notify alert followed by a TCP FIN.</t>

         <figure align="center" anchor="subscribe_resp" title="SUBSCRIBE Response Message"><artwork align="center"><![CDATA[
                                1  1  1  1  1  1
  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+  \
|                  MESSAGE ID                   |   \
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    |
|QR| OPCODE(6) |         Z          |   RCODE   |    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    |
|             QDCOUNT (MUST BE ZERO)            |    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+     > HEADER
|             ANCOUNT (MUST BE ZERO)            |    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    |
|             NSCOUNT (MUST BE ZERO)            |    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    |
|             ARCOUNT (MUST BE ZERO)            |   /
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+  /
]]>
</artwork></figure>
<?rfc needLines="20" ?>
         <t>In the SUBSCRIBE response the RCODE indicates whether or not the subscription was accepted. Supported RCODEs are as follows:</t>
         <texttable title="SUBSCRIBE Response codes" anchor="subscribe_rcodes">
         <ttcol align="left">Mnemonic</ttcol>
         <ttcol align="center">Value</ttcol>
         <ttcol align="left">Description</ttcol>
         <c>NOERROR</c><c>0</c><c>SUBSCRIBE successful.</c>
         <c>FORMERR</c><c>1</c><c>Server failed to process request due to a malformed request.</c>
         <c>SERVFAIL</c><c>2</c><c>Server failed to process request due to a problem with the server.</c>
         <c>NOTIMP</c><c>4</c><c>Server does not implement DSO.</c>
         <c>REFUSED</c><c>5</c><c>Server refuses to process request for policy or security reasons.</c>
         <c>NOTAUTH</c><c>9</c><c>Server is not authoritative for the requested name.</c>
         <c>DSOTYPENI</c><c>11</c><c>SUBSCRIBE operation not supported.</c>
         </texttable>

         <t>This document specifies only these RCODE values for SUBSCRIBE Responses. Servers sending SUBSCRIBE Responses SHOULD use one of these values. Note that NXDOMAIN is not a valid RCODE in response to a SUBSCRIBE Request. However, future circumstances may create situations where other RCODE values are appropriate in SUBSCRIBE Responses, so clients MUST be prepared to accept SUBSCRIBE Responses with any other RCODE value.</t>

         <t>If the server sends a nonzero RCODE in the SUBSCRIBE response, that means:
           <?rfc subcompact="yes" ?>
           <list style="letters">
             <t>the client is (at least partially) misconfigured,</t>
             <t>the server resources are exhausted, or</t>
             <t>there is some other unknown failure on the server.</t>
           </list>
           <?rfc subcompact="no" ?>
         In any case, the client shouldn't retry the subscription to this server right away. If multiple SRV records were returned as described in <xref target="discovery"/>, <xref target="SRV"/>, a subsequent server can be tried immediately.</t>
         <t>If the client has other successful subscriptions to this server, these subscriptions remain even though additional subscriptions may be refused. Neither the client nor the server are required to close the connection, although, either end may choose to do so.</t>
         <t>If the server sends a nonzero RCODE then it SHOULD append a Retry Delay TLV <xref target="RFC8490"/> to the response specifying a delay before the client attempts this operation again. Recommended values for the delay for different RCODE values are given below. These recommended values apply both to the default values a server should place in the Retry Delay TLV, and the default values a client should assume if the server provides no Retry Delay TLV.
           <list style="bullets">
             <t>For RCODE = 1 (FORMERR) the delay may be any value selected by the implementer. A value of five minutes is RECOMMENDED, to reduce the risk of high load from defective clients.</t>

             <t>For RCODE = 2 (SERVFAIL) the delay should be chosen according to the level of server overload and the anticipated duration of that overload. By default, a value of one minute is RECOMMENDED. If a more serious server failure occurs, the delay may be longer in accordance with the specific problem encountered.</t>

             <t>For RCODE = 4 (NOTIMP), which occurs on a server that doesn't implement
             <xref target="RFC8490">DNS Stateful Operations</xref>,
             it is unlikely that the server will begin supporting DSO
             in the next few minutes, so the retry delay SHOULD be one hour.
             Note that in such a case, a server that doesn't implement DSO
             is unlikely to place a Retry Delay TLV in its response, so this
             recommended value in particular applies to what a client should assume by default.</t>

             <t>For RCODE = 5 (REFUSED), which occurs on a server that implements DNS Push Notifications, but is currently configured to disallow DNS Push Notifications, the retry delay may be any value selected by the implementer and/or configured by the operator.</t>
             <t>If the server being queried is listed in a
             <spanx style="verb">_dns&nbhy;push&nbhy;tls._tcp.&lt;zone&gt;</spanx>
             SRV record for the zone, then this is a misconfiguration,
             since this server is being advertised as supporting DNS Push Notifications for this zone,
             but the server itself is not currently configured to perform that task.
             Since it is possible that the misconfiguration may be repaired
             at any time, the retry delay should not be set too high.  By default,
             a value of 5 minutes is RECOMMENDED.</t>

             <t>For RCODE = 9 (NOTAUTH), which occurs on a server that implements DNS Push Notifications, but is not configured to be authoritative for the requested name, the retry delay may be any value selected by the implementer and/or configured by the operator.</t>
             <t>If the server being queried is listed in a
             <spanx style="verb">_dns&nbhy;push&nbhy;tls._tcp.&lt;zone&gt;</spanx>
             SRV record for the zone, then this is a misconfiguration,
             since this server is being advertised as supporting DNS Push Notifications for this zone,
             but the server itself is not currently configured to perform that task.
             Since it is possible that the misconfiguration may be repaired
             at any time, the retry delay should not be set too high.  By default,
             a value of 5 minutes is RECOMMENDED.</t>

             <t>For RCODE = 11 (DSOTYPENI),
             which occurs on a server that implements DSO but doesn't implement DNS Push Notifications,
             it is unlikely that the server will begin supporting DNS Push Notifications
             in the next few minutes, so the retry delay SHOULD be one hour.</t>

             <t>For other RCODE values, the retry delay should be set by the server as appropriate for that error condition. By default, a value of 5 minutes is RECOMMENDED.</t>
           </list>
         </t>
         <t>For RCODE = 9 (NOTAUTH), the time delay applies to requests for other names falling within the same zone. Requests for names falling within other zones are not subject to the delay. For all other RCODEs the time delay applies to all subsequent requests to this server.</t>

         <t>After sending an error response the server MAY allow the session to remain open,
         or MAY send a DNS Push Notification Retry Delay Operation TLV instructing the client to close the session,
         as described in the <xref target="RFC8490">DSO specification</xref>.
         Clients MUST correctly handle both cases.</t>

<?rfc needLines="48" ?>
       </section>
     </section>

     <section title="DNS Push Notification Updates" anchor="push">
       <t>Once a subscription has been successfully established, the server generates PUSH messages to send to the client as appropriate. In the case that the answer set was already non-empty at the moment the subscription was established, an initial PUSH message will be sent immediately following the SUBSCRIBE Response. Subsequent changes to the answer set are then communicated to the client in subsequent PUSH messages.</t>

       <section title="PUSH Message">

         <t>A PUSH unidirectional message begins with the standard
         <xref target="RFC8490">DSO 12-byte header</xref>, followed by the PUSH primary TLV.
         A PUSH message is illustrated in <xref target="push_msg"/>.</t>

         <t>In accordance with the definition of DSO unidirectional messages,
         the MESSAGE ID field MUST be zero.
         There is no client response to a PUSH message.</t>

         <t>The other header fields MUST be set as described in the
         <xref target="RFC8490">DSO spec-ification</xref>.
         The DNS OPCODE field contains the OPCODE value for DNS Stateful Operations (6).
         The four count fields MUST be zero, and the corresponding four sections MUST be empty (i.e., absent).</t>

         <t>A client MUST NOT send a PUSH message.
         If a client does send a PUSH message,
         or a PUSH message is sent with the QR bit set indicating that it is a response,
         this is a fatal error and the receiver should immediately abort the connection with a TLS close_notify alert followed by a TCP FIN.</t>

         <t>The DSO-TYPE is PUSH (tentatively 0x41).</t>

         <t>The DSO-LENGTH is the length of the DSO-DATA that follows, which specifies
         the changes being communicated.</t>

         <t>The DSO-DATA contains one or more change notifications.
         A PUSH Message MUST contain at least one change notification.
         If a PUSH Message is received that contains no change notifications,
         this is a fatal error, and the receiver MUST immediately terminate
         the connection with a TLS close_notify alert followed by a TCP FIN.</t>

         <t>The change notification records are formatted similarly to how
         DNS Resource Records are conventionally expressed in DNS messages,
         as illustrated in <xref target="push_msg"/>,
         and are interpreted as described below.</t>

         <t>The TTL field holds an unsigned 32-bit integer <xref target="RFC2181"/>.
         If the TTL is in the range 0 to 2,147,483,647 seconds (2^31 - 1, or 0x7FFFFFFF),
         then a new DNS Resource Record with the given name, type, class and RDATA is added.
         A TTL of 0 means that this record should be retained for as long as the subscription is active,
         and should be discarded immediately the moment the subscription is cancelled.</t>

         <t>If the TTL has the value 0xFFFFFFFF, then the
         DNS Resource Record with the given name, type, class and RDATA is removed.</t>

         <t>If the TTL has the value 0xFFFFFFFE, then this is a 'collective' remove notification.
         For collective remove notifications RDLEN MUST be zero and consequently the RDATA MUST be empty.
         If a change notification is received where TTL = 0xFFFFFFFE and RDLEN is not zero,
         this is a fatal error, and the receiver MUST immediately terminate
         the connection with a TLS close_notify alert followed by a TCP FIN.
         There are three types of collective remove notification:</t>

         <t>For collective remove notifications,
         if CLASS is not 255 (ANY) and TYPE is not 255 (ANY)
         then for the given name this deletes all records of the specified type in the specified class.</t>

         <t>For collective remove notifications,
         if CLASS is not 255 (ANY) and TYPE is 255 (ANY)
         then for the given name this deletes all records of all types in the specified class.</t>

         <t>For collective remove notifications,
         if CLASS is 255 (ANY),
         then for the given name this deletes all records of all types in all classes.
         In this case TYPE MUST be set to zero on transmission, and MUST be silently ignored on reception.</t>

         <t>Summary of change notification types:
           <list style="bullets">
             <t>Delete all RRsets from a name, in all classes<vspace />
             TTL=0xFFFFFFFE, RDLENGTH=0, CLASS=255 (ANY)</t>

             <t>Delete all RRsets from a name, in given class:<vspace />
             TTL=0xFFFFFFFE, RDLENGTH=0, CLASS specifies class, TYPE=255 (ANY)</t>

             <t>Delete specified RRset from a name, in given class:<vspace />
             TTL=0xFFFFFFFE, RDLENGTH=0<vspace />
             CLASS and TYPE specify the RRset being deleted</t>

             <t>Delete an individual RR from a name:<vspace />
             TTL=0xFFFFFFFF<vspace />
             CLASS, TYPE, RDLENGTH and RDATA specify the RR being deleted.</t>

             <t>Add individual RR to a name<vspace />
             TTL⩾0<vspace />
             CLASS, TYPE, RDLENGTH, RDATA and TTL specify the RR being added.</t>
           </list>
         </t>

         <t>Note that it is valid for the RDATA of an added or removed DNS Resource Record to be empty (zero length).
         For example, an <xref target="RFC3123">Address Prefix List Resource Record</xref> may have empty RDATA.
         Therefore, a change notification with RDLEN=0 does not automatically indicate a remove notification.
         If RDLEN=0 and TTL is the in the range 0 - 0x7FFFFFFF, this change notification signals the addition of a
         record with the given name, type, class, and empty RDATA.
         If RDLEN=0 and TTL = 0xFFFFFFFF, this change notification signals the removal specifically of that single
         record with the given name, type, class, and empty RDATA.</t>

         <t>If the TTL is any value other than 0xFFFFFFFF, 0xFFFFFFFE, or a value in the range 0 - 0x7FFFFFFF,
         then the receiver SHOULD silently ignore this particular change notification record.
         The connection is not terminated and other valid change notification records
         within this PUSH message are processed as usual.</t>

         <t>For efficiency, when generating a PUSH message, a server SHOULD
         include as many change notifications as it has immediately available to send,
         rather than sending each change notification as a separate DSO message.
         Once it has exhausted the list of change notifications immediately available to send,
         a server SHOULD then send the PUSH message immediately,
         rather than waiting to see if additional change notifications become available.</t>

         <t>For efficiency, when generating a PUSH message, a server SHOULD
         use standard DNS name compression,
         with offsets relative to the beginning of the DNS message <xref target="RFC1035"/>.
         When multiple change notifications in a single PUSH message have the same owner name,
         this name compression can yield significant savings.
         Name compression should be performed as specified in Section 18.14 of the
         <xref target="RFC6762">Multicast DNS specification</xref>, namely,
         owner names should always be compressed,
         and names appearing within RDATA should be compressed for only the RR types listed below:
         <list style="hanging">
           <t>NS, CNAME, PTR, DNAME, SOA, MX, AFSDB, RT, KX, RP, PX, SRV, NSEC</t>
         </list></t>

         <t>Servers may generate PUSH messages up to a maximum DNS message length of 16,382 bytes,
         counting from the start of the DSO 12-byte header.
         Including the two-byte length prefix that is used to frame DNS over a byte stream
         like TLS, this makes a total of 16,384 bytes.
         Servers MUST NOT generate PUSH messages larger than this.
         Where the immediately available change notifications
         are sufficient to exceed a DNS message length of 16,382 bytes,
         the change notifications MUST be communicated in separate PUSH messages
         of up to 16,382 bytes each.
         DNS name compression becomes less effective for messages larger than 16,384 bytes,
         so little efficiency benefit is gained by sending messages larger than this.</t>

         <t>If a client receives a PUSH message with
         a DNS message length larger than 16,382 bytes, the
         this is a fatal error, and the receiver MUST immediately terminate
         the connection with a TLS close_notify alert followed by a TCP FIN.</t>

         <figure align="center" anchor="push_msg" title="PUSH Message"><artwork align="center"><![CDATA[
                                1  1  1  1  1  1
  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+  \
|           MESSAGE ID (MUST BE ZERO)           |   \
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    |
|QR| OPCODE(6) |         Z          |   RCODE   |    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    |
|             QDCOUNT (MUST BE ZERO)            |    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+     > HEADER
|             ANCOUNT (MUST BE ZERO)            |    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    |
|             NSCOUNT (MUST BE ZERO)            |    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    |
|             ARCOUNT (MUST BE ZERO)            |   /
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+  /
|      DSO-TYPE = PUSH (tentatively 0x41)       |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|   DSO-LENGTH (number of octets in DSO-DATA)   |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+  \
\                     NAME                      \   \
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    |
|                     TYPE                      |    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    |
|                     CLASS                     |    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    |
|                      TTL                      |    |
|     (32-bit unsigned big-endian integer)      |     > DSO-DATA
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    |
|  RDLEN (16-bit unsigned big-endian integer)   |    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    |
\           RDATA (sized as necessary)          \    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    |
:     NAME, TYPE, CLASS, TTL, RDLEN, RDATA      :    |
:             Repeated As Necessary             :   /
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+  /]]></artwork></figure>

         <t>When processing the records received in a PUSH Message, the receiving client MUST validate that the records being added or deleted correspond with at least one currently active subscription on that session. Specifically, the record name MUST match the name given in a SUBSCRIBE request, subject to the usual established DNS case-insensitivity for US-ASCII letters.
         If the TYPE in the SUBSCRIBE request was not ANY (255) then the TYPE of the record must match the TYPE given in the SUBSCRIBE request.
         If the CLASS in the SUBSCRIBE request was not ANY (255) then the CLASS of the record must match the CLASS given in the SUBSCRIBE request.
         If a matching active subscription on that session is not found, then that individual record addition/deletion is silently ignored. Processing of other additions and deletions in this message is not affected. The DSO session is not closed. This is to allow for the unavoidable race condition where a client sends an outbound UNSUBSCRIBE while inbound PUSH messages for that subscription from the server are still in flight.</t>
  
         <t>In the case where a single change affects more than one active subscription, only one PUSH message is sent. For example, a PUSH message adding a given record may match both a SUBSCRIBE request with the same TYPE and a different SUBSCRIBE request with TYPE=ANY (255). It is not the case that two PUSH messages are sent because the new record matches two active subscriptions.</t>
  
         <t>The server SHOULD encode change notifications in the most efficient manner possible. For example, when three AAAA records are deleted from a given name, and no other AAAA records exist for that name, the server SHOULD send a "delete an RRset from a name" PUSH message, not three separate "delete an individual RR from a name" PUSH messages. Similarly, when both an SRV and a TXT record are deleted from a given name, and no other records of any kind exist for that name, the server SHOULD send a "delete all RRsets from a name" PUSH message, not two separate "delete an RRset from a name" PUSH messages.</t>
  
         <t>A server SHOULD combine multiple change notifications in a single PUSH message when possible, even if those change notifications apply to different subscriptions. Conceptually, a PUSH message is a session-level mechanism, not a subscription-level mechanism.</t>
  
         <t>The TTL of an added record is stored by the client.  While the subscription
           is active, the TTL is not decremented, because a change to the TTL would
           produce a new update.
           For as long as a relevant subscription remains active, the client
           SHOULD assume that when a record goes away the server will notify it
           of that fact.  Consequently, a client does not have to poll to verify
           that the record is still there.  Once a subscription is cancelled
           (individually, or as a result of the DSO session being closed) record
           aging for records covered by the subscription resumes and records are
           removed from the local cache when their  TTL reaches zero.</t>
<?rfc needLines="48" ?>
       </section>
     </section>

     <section title="DNS Push Notification UNSUBSCRIBE" anchor="unsubscribe">
       <t>To cancel an individual subscription without closing the entire DSO session, the client sends an UNSUBSCRIBE message over the established DSO session to the server. The UNSUBSCRIBE message is encoded as a
       DSO unidirectional message <xref target="RFC8490"/>. This specification defines a primary unidirectional DSO TLV for DNS Push Notification UNSUBSCRIBE Messages (tentatively DSO Type Code 0x42).</t>

       <t>A server MUST NOT send an UNSUBSCRIBE message.
       If a server does send an UNSUBSCRIBE message over a DSO session initiated by a client,
       or an UNSUBSCRIBE message is sent with the QR bit set indicating that it is a response,
       this is a fatal error and the receiver should immediately abort the connection with a TLS close_notify alert followed by a TCP FIN.</t>

       <section title="UNSUBSCRIBE Message">

         <t>An UNSUBSCRIBE unidirectional message begins with the standard
         <xref target="RFC8490">DSO 12-byte header</xref>, followed by the UNSUBSCRIBE primary TLV.
         An UNSUBSCRIBE message is illustrated in <xref target="unsubscribe_req"/>.</t>         

         <t>In accordance with the definition of DSO unidirectional messages,
         the MESSAGE ID field MUST be zero.
         There is no server response to an UNSUBSCRIBE message.</t>

         <t>The other header fields MUST be set as described in the
         <xref target="RFC8490">DSO spec-ification</xref>.
         The DNS OPCODE field contains the OPCODE value for DNS Stateful Operations (6).
         The four count fields MUST be zero, and the corresponding four sections MUST be empty (i.e., absent).</t>

         <t>The DSO-TYPE is UNSUBSCRIBE (tentatively 0x42).</t>

         <t>The DSO-LENGTH field contains the value 2, the length of the 2-octet MESSAGE ID contained in the DSO-DATA.</t>

         <t>The DSO-DATA contains the value given in the MESSAGE ID field of an active SUBSCRIBE request.
         This is how the server knows which SUBSCRIBE request is being cancelled.
         After receipt of the UNSUBSCRIBE message, the SUBSCRIBE request is no longer active.</t>

         <t>It is allowable for the client to issue an UNSUBSCRIBE message for a previous SUBSCRIBE request
         for which the client has not yet received a SUBSCRIBE response.
         This is to allow for the case where a client starts and stops a subscription in less than the
         round-trip time to the server.
         The client is NOT required to wait for the SUBSCRIBE response before issuing the UNSUBSCRIBE message.</t>

         <t>Consequently, it is possible for a server to receive an UNSUBSCRIBE message
         that does not match any currently active subscription.
         This can occur when a client sends a SUBSCRIBE request,
         which subsequently fails and returns an error code,
         but the client sent an UNSUBSCRIBE message before it
         became aware that the SUBSCRIBE request had failed.
         Because of this, servers MUST silently ignore
         UNSUBSCRIBE messages that do not match any currently active subscription.</t>

         <figure align="center" anchor="unsubscribe_req" title="UNSUBSCRIBE Message"><artwork align="center"><![CDATA[
                                1  1  1  1  1  1
  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+  \
|           MESSAGE ID (MUST BE ZERO)           |   \
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    |
|QR| OPCODE(6) |         Z          |   RCODE   |    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    |
|             QDCOUNT (MUST BE ZERO)            |    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+     > HEADER
|             ANCOUNT (MUST BE ZERO)            |    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    |
|             NSCOUNT (MUST BE ZERO)            |    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    |
|             ARCOUNT (MUST BE ZERO)            |   /
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+  /
|   DSO-TYPE = UNSUBSCRIBE (tentatively 0x42)   |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                DSO-LENGTH (2)                 |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+  \
|              SUBSCRIBE MESSAGE ID             |   > DSO-DATA
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+  /]]></artwork></figure>

<?rfc needLines="48" ?>
       </section>
     </section>

     <section title="DNS Push Notification RECONFIRM" anchor="reconfirm">
       <t>Sometimes, particularly when used with a <xref target="DisProx">Discovery Proxy</xref>, a DNS Zone may contain stale data. When a client encounters data that it believes may be stale (e.g., an SRV record referencing a target host+port that is not responding to connection requests) the client can send a RECONFIRM message to ask the server to re-verify that the data is still valid. For a Discovery Proxy, this causes it to issue new Multicast DNS queries to ascertain whether the target device is still present. How the Discovery Proxy causes these new Multicast DNS queries to be issued depends on the details of the underlying Multicast DNS implementation being used. For example, a Discovery Proxy built on Apple's dns_sd.h API responds to a DNS Push Notification RECONFIRM message by calling the underlying API's DNSServiceReconfirmRecord() routine.</t>
       
       <t>For other types of DNS server, the RECONFIRM operation is currently undefined, and SHOULD result in a NOERROR response, but otherwise need not cause any action to occur.</t>

       <t>Frequent use of RECONFIRM operations may be a sign of network unreliability, or some kind of misconfiguration, so RECONFIRM operations MAY be logged or otherwise communicated to a human administrator to assist in detecting and remedying such network problems.</t>

       <t>If, after receiving a valid RECONFIRM message, the server determines that the disputed records are in fact no longer valid, then subsequent DNS PUSH Messages will be generated to inform interested clients. Thus, one client discovering that a previously-advertised device (like a network printer) is no longer present has the side effect of informing all other interested clients that the device in question is now gone.</t>

       <t>A server MUST NOT send a RECONFIRM message.
       If a server does send a RECONFIRM message over a DSO session initiated by a client,
       or a RECONFIRM message is sent with the QR bit set indicating that it is a response,
       this is a fatal error and the receiver should immediately abort the connection with a TLS close_notify alert followed by a TCP FIN.</t>

<?rfc needLines="20" ?>
       <section title="RECONFIRM Message">

         <t>A RECONFIRM unidirectional message begins with the standard
         <xref target="RFC8490">DSO 12-byte header</xref>, followed by the RECONFIRM primary TLV.<vspace />
         A RECONFIRM message is illustrated in <xref target="reconfirm_req"/>.</t>

         <t>In accordance with the definition of DSO unidirectional messages,
         the MESSAGE ID field MUST be zero.
         There is no server response to a RECONFIRM message.</t>

         <t>The other header fields MUST be set as described in the
         <xref target="RFC8490">DSO spec-ification</xref>.
         The DNS OPCODE field contains the OPCODE value for DNS Stateful Operations (6).
         The four count fields MUST be zero, and the corresponding four sections MUST be empty (i.e., absent).</t>

         <t>The DSO-TYPE is RECONFIRM (tentatively 0x43).</t>

         <t>The DSO-LENGTH is the length of the data that follows, which specifies
         the name, type, class, and content of the record being disputed.</t>

         <t>The DSO-DATA for a RECONFIRM message MUST contain exactly one record.
         The DSO-DATA for a RECONFIRM message has no count field to specify more than one record.
         Since RECONFIRM messages are sent over TCP, multiple RECONFIRM messages
         can be concatenated in a single TCP stream and packed efficiently into TCP segments.</t>

         <t>TYPE MUST NOT be the value ANY (255) and CLASS MUST NOT be the value ANY (255).</t>

         <t>DNS wildcarding is not supported. That is, a wildcard ("*") in a RECONFIRM message matches only a literal wildcard character ("*") in the zone, and nothing else.</t>

         <t>Aliasing is not supported. That is, a CNAME in a RECONFIRM message matches only a literal CNAME record in the zone, and no other records with the same owner name.</t>

         <t>Note that there is no RDLEN field, since the length of the RDATA can be inferred from DSO-LENGTH, so an additional RDLEN field would be redundant.</t>

         <figure align="center" anchor="reconfirm_req" title="RECONFIRM Message"><artwork align="center"><![CDATA[
                                1  1  1  1  1  1
  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+  \
|                  MESSAGE ID                   |   \
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    |
|QR| OPCODE(6) |         Z          |   RCODE   |    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    |
|             QDCOUNT (MUST BE ZERO)            |    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+     > HEADER
|             ANCOUNT (MUST BE ZERO)            |    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    |
|             NSCOUNT (MUST BE ZERO)            |    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    |
|             ARCOUNT (MUST BE ZERO)            |   /
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+  /
|    DSO-TYPE = RECONFIRM (tentatively 0x43)    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|   DSO-LENGTH (number of octets in DSO-DATA)   |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+  \
\                     NAME                      \   \
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    |
|                     TYPE                      |    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+     > DSO-DATA
|                     CLASS                     |    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    |
\                     RDATA                     \   /
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+  /]]></artwork></figure>

<?rfc needLines="48" ?>
       </section>

     </section>
     <section title="DNS Stateful Operations TLV Context Summary">
       <t>This document defines four new DSO TLVs. As suggested in Section 8.2 of the <xref target="RFC8490">DNS Stateful Operations specification</xref>, the valid contexts of these new TLV types are summarized below.</t>
       <t>The client TLV contexts are:
         <?rfc subcompact="yes" ?>
         <list style="hanging">
           <t hangText="C-P:">Client request message, primary TLV</t>
           <t hangText="C-U:">Client unidirectional message, primary TLV</t>
           <t hangText="C-A:">Client request or unidirectional message, additional TLV</t>
           <t hangText="CRP:">Response back to client, primary TLV</t>
           <t hangText="CRA:">Response back to client, additional TLV</t>
         </list>
         <?rfc subcompact="no" ?>
       </t>
       <texttable title="DSO TLV Client Context Summary" anchor="tlv_client_contexts">
       <ttcol align="right">TLV Type</ttcol>
       <ttcol align="center">C-P</ttcol>
       <ttcol align="center">C-U</ttcol>
       <ttcol align="center">C-A</ttcol>
       <ttcol align="center">CRP</ttcol>
       <ttcol align="center">CRA</ttcol>
       <c>SUBSCRIBE</c><c>X</c><c></c><c></c><c></c><c></c>
       <c>PUSH</c><c></c><c></c><c></c><c></c><c></c>
       <c>UNSUBSCRIBE</c><c></c><c>X</c><c></c><c></c><c></c>
       <c>RECONFIRM</c><c></c><c>X</c><c></c><c></c><c></c>
     </texttable>
     <t>The server TLV contexts are:
       <?rfc subcompact="yes" ?>
       <list style="hanging">
         <t hangText="S-P:">Server request message, primary TLV</t>
         <t hangText="S-U:">Server unidirectional message, primary TLV</t>
         <t hangText="S-A:">Server request or unidirectional message, additional TLV</t>
         <t hangText="SRP:">Response back to server, primary TLV</t>
         <t hangText="SRA:">Response back to server, additional TLV</t>
       </list>
       <?rfc subcompact="no" ?>
     </t>
     <texttable title="DSO TLV Server Context Summary" anchor="tlv_server_contexts">
     <ttcol align="right">TLV Type</ttcol>
     <ttcol align="center">S-P</ttcol>
     <ttcol align="center">S-U</ttcol>
     <ttcol align="center">S-A</ttcol>
     <ttcol align="center">SRP</ttcol>
     <ttcol align="center">SRA</ttcol>
     <c>SUBSCRIBE</c><c></c><c></c><c></c><c></c><c></c>
     <c>PUSH</c><c></c><c>X</c><c></c><c></c><c></c>
     <c>UNSUBSCRIBE</c><c></c><c></c><c></c><c></c><c></c>
     <c>RECONFIRM</c><c></c><c></c><c></c><c></c><c></c>
   </texttable>
     </section>
     <section title="Client-Initiated Termination">

       <t>An individual subscription is terminated by sending an UNSUBSCRIBE TLV for that specific subscription, or all subscriptions can be cancelled at once by the client closing the DSO session. When a client terminates an individual subscription (via UNSUBSCRIBE) or all subscriptions on that DSO session (by ending the session) it is signaling to the server that it is longer interested in receiving those particular updates. It is informing the server that the server may release any state information it has been keeping with regards to these particular subscriptions.</t>

       <t>After terminating its last subscription on a session via UNSUBSCRIBE, a client MAY close the session immediately, or it may keep it open if it anticipates performing further operations on that session in the future. If a client wishes to keep an idle session open, it MUST respect the maximum idle time required by the server <xref target="RFC8490"/>.</t>

       <t>If a client plans to terminate one or more subscriptions on a session and doesn't intend to keep that session open, then as an efficiency optimization it MAY instead choose to simply close the session, which implicitly terminates all subscriptions on that session. This may occur because the client computer is being shut down, is going to sleep, the application requiring the subscriptions has terminated, or simply because the last active subscription on that session has been cancelled.</t>

       <t>When closing a session, a client should perform an orderly close of
       the TLS session in order to allow for future TLS session resumption
       with the server (if available). See <xref target="resumption"/> below.
       Typical APIs will provide a session
       close method that will send a TLS close_notify alert. This instructs
       the recipient that the sender will not send any more data over the
       session.</t>

       <t>If the session is forcibly closed at the TCP level by sending a
       RST from either end of the connection, data may be lost and TLS
       session resumption of this session will not be possible.</t>
     </section>

     <section title="Client Fallback to Polling" anchor="polling">
        <t>There are cases where a client may exhaust all avenues for
        establishing a DNS Push Notification subscription without success.
        This can happen if the client's configured recursive resolver
        does not support DNS over TLS, or
        supports DNS over TLS but is not listening on TCP port 853, or
        supports DNS over TLS on TCP port 853 but does not support DSO on that port,
        or for some other reason is unable to provide a DNS Push Notification subscription.
        In this case the client will attempt to communicate directly with an appropriate server,
        and it may be that the zone apex discovery fails, or there is no
        <spanx style="verb">_dns&nbhy;push&nbhy;tls._tcp.&lt;zone&gt;</spanx> SRV record,
        or server indicated in the SRV record is misconfigured,
        or is unresponsive for some other reason.</t>

        <t>Regardless of the reason for the failure,
        after being unable to establish the desired DNS Push Notification subscription,
        it is likely that the client will still wish to know the answer it seeks,
        even if that answer cannot be obtained with the timely
        change notifications provided by DNS Push Notifications.
        In such cases it is likely that the client will obtain
        the answer it seeks via a conventional DNS query instead,
        repeated at some interval to detect when the answer RRset changes.</t>

        <t>In the case where a client responds to its
        failure to establish a DNS Push Notification subscription
        by falling back to polling with conventional DNS queries instead,
        the polling rate should be controlled to avoid placing excessive burden on the server.
        The interval between successive DNS queries for the same name, type and class
        SHOULD be at least the minimum of 900 seconds (15 minutes),
        or two seconds more than the TTL of the answer RRset.</t>

        <t>The reason that for TTLs shorter than 898 seconds the query should
        not be reissued until two seconds *after* the answer RRset has expired is
        to ensure that the answer RRset has also expired from
        the cache on the client's configured recursive resolver.
        Otherwise
        (particularly if the clocks on the client and the
        recursive resolver do not run at precisely the same rate)
        there's a risk of a race condition where
        the client queries its configured recursive resolver just as the answer RRset has
        one second remaining in the recursive resolver's cache.
        The client would then receive a reply telling it that the answer RRset
        has one second remaining, and then the client would then re-query the
        recursive resolver again one second later when the answer RRset
        actually expires, and only then would the
        recursive resolver issue a new query to fetch new fresh
        data from the authoritative server.
        Waiting until the answer RRset has definitely expired from the
        the cache on the client's configured recursive resolver
        avoids this race condition and unnecessary additional queries it causes.</t>

        <t>Each time a client is about to reissue its query to discover
        changes to the answer RRset, it should first make a new attempt to
        establish a DNS Push Notification subscription, using previously
        cached DNS answers as appropriate.
        After a temporary misconfiguration has been remedied,
        this allows a client that is polling to return to using
        DNS Push Notifications for asynchronous change notification.</t>
<?rfc needLines="20" ?>
     </section>
   </section>

   <section title="Security Considerations" anchor="Security">
     <t>The Strict Privacy Usage Profile for DNS over TLS is REQUIRED for DNS Push Notifications <xref target="RFC8310"/>. Cleartext connections for DNS Push Notifications are not permissible. Since this is a new protocol, transition mechanisms from the Opportunistic Privacy profile are unnecessary.</t>

     <t>Also, see Section 9 of the DNS over (D)TLS Usage Profiles document <xref target="RFC8310"/> for additional recommendations for various versions of TLS usage.</t>

     <t>As a consequence of requiring TLS, client certificate authentication and verification may also be enforced by the server for stronger client-server security or end-to-end security. However, recommendations for security in particular deployment scenarios are outside the scope of this document.</t>

     <t>DNSSEC is RECOMMENDED for the authentication of DNS Push Notification servers. TLS alone does not provide complete security. TLS certificate verification can provide reasonable assurance that the client is really talking to the server associated with the desired host name, but since the desired host name is learned via a DNS SRV query, if the SRV query is subverted then the client may have a secure connection to a rogue server. DNSSEC can provided added confidence that the SRV query has not been subverted.</t>

     <section title="Security Services">
       <t>It is the goal of using TLS to provide the following security services:
         <list style="hanging">
           <t hangText="Confidentiality:">All application-layer communication is encrypted with the goal that no party should be able to decrypt it except the intended receiver.</t>
           <t hangText="Data integrity protection:">Any changes made to the communication in transit are detectable by the receiver.</t>
           <t hangText="Authentication:">An end-point of the TLS communication is authenticated as the intended entity to communicate with.</t>
           <t hangText="Anti-replay protection:">TLS provides for the detection of and prevention against messages sent previously over a TLS connection (such as DNS Push Notifications). Prior messages cannot be re-sent at a later time as a form of a man-in-the-middle attack.</t>
         </list>
       </t>
       <t>Deployment recommendations on the appropriate key lengths and cypher suites are beyond the scope of this document. Please refer to <xref target="RFC7525">TLS Recommendations</xref> for the best current practices. Keep in mind that best practices only exist for a snapshot in time and recommendations will continue to change. Updated versions or errata may exist for these recommendations.</t>
     </section>

     <section title="TLS Name Authentication" anchor="tls_name_auth">
       <t>As described in <xref target="discovery"/>, the client discovers the DNS Push Notification server using an SRV lookup for the record name <spanx style="verb">_dns&nbhy;push&nbhy;tls._tcp.&lt;zone&gt;</spanx>. The server connection endpoint SHOULD then be authenticated using DANE TLSA records for the associated SRV record. This associates the target's name and port number with a trusted TLS certificate <xref target="RFC7673"/>. This procedure uses the TLS Server Name Indication (SNI) extension <xref target="RFC6066"/> to inform the server of the name the client has authenticated through the use of TLSA records. Therefore, if the SRV record passes DNSSEC validation and a TLSA record matching the target name is useable, an SNI extension must be used for the target name to ensure the client is connecting to the server it has authenticated. If the target name does not have a usable TLSA record, then the use of the SNI extension is optional. See <xref target="RFC8310">Usage Profiles for DNS over TLS and DNS over DTLS</xref> for more information on authenticating domain names.</t>
     </section>

     <section title="TLS Early Data" anchor="early_data">
       <t>DSO messages with the SUBSCRIBE TLV as the Primary TLV are permitted in TLS early data.
       Using TLS early data can save one network round trip, and can result in the client obtaining results faster.</t>

       <t>However, there are some factors to consider before using TLS early data.</t>

       <t>TLS Early Data is not forward secret.
       In cases where forward secrecy of DNS Push Notification subscriptions is required,
       the client should not use TLS Early Data.</t>

       <t>With TLS early data there are no guarantees of non-replay between connections.
       If packets are duplicated and delayed in the network,
       the later arrivals could be mistaken for new subscription requests.
       Generally this is not a major concern,
       since the amount of state generated on the server for
       these spurious subscriptions is small and short-lived,
       since the TCP connection will not complete the three-way handshake.
       Servers MAY choose to implement rate-limiting measures that are activated when
       the server detects an excessive number of spurious subscription requests.</t>

       <t>For further guidance please see Section 2.3, Section 8, and Appendix E.5
       of the TLS 1.3 specification <xref target="RFC8446"/>.</t>
     </section>

     <section title="TLS Session Resumption" anchor="resumption">
       <t>TLS Session Resumption is permissible on DNS Push Notification servers. The server may keep TLS state with Session IDs <xref target="RFC8446"/> or operate in stateless mode by sending a Session Ticket <xref target="RFC5077"/> to the client for it to store. However, closing the TLS connection terminates the DSO session.  When the TLS session is resumed, the DNS Push Notification server will not have any subscription state and will proceed as with any other new DSO session. Use of TLS Session Resumption may allow a TLS connection to be set up more quickly, but the client will still have to recreate any desired subscriptions.</t>
<?rfc needLines="23" ?>
     </section>
   </section>

   <section title="IANA Considerations" anchor="IANA">

     <t>This document defines a new service name to be published in the IANA Registry Service Types <xref target="RFC6335"/><xref target="ST"/> that is only applicable for the TCP protocol.</t>
     <texttable title="IANA Service Type Assignments" anchor="iana_service_table">
       <ttcol width="25%" align="left">Name</ttcol>
       <ttcol align="center">Port</ttcol>
       <ttcol align="center">Value</ttcol>
       <ttcol align="left">Definition</ttcol>
       <c>DNS Push Notification Service Type</c>
       <c>None</c>
       <c><spanx style="verb">_dns&nbhy;push&nbhy;tls._tcp</spanx></c>
       <c><xref target="discovery"/></c>
     </texttable>

     <t>This document also defines four new DNS Stateful Operation TLV types to be recorded in the IANA DSO Type Code Registry.</t>
     <texttable title="IANA DSO TLV Type Code Assignments" anchor="iana_tlv_table">
       <ttcol align="left">Name</ttcol>
       <ttcol align="center">Value</ttcol>
       <ttcol width="5%" align="center">Early Data</ttcol>
       <ttcol align="center">Status</ttcol>
       <ttcol width="5%" align="left">Definition</ttcol>
       <c>SUBSCRIBE</c>
       <c>TBA (0x40)</c>
       <c>OK</c>
       <c>Standards Track</c>
       <c><xref target="subscribe"/></c>
       <c>PUSH</c>
       <c>TBA (0x41)</c>
       <c>NO</c>
       <c>Standards Track</c>
       <c><xref target="push"/></c>
       <c>UNSUBSCRIBE</c>
       <c>TBA (0x42)</c>
       <c>NO</c>
       <c>Standards Track</c>
       <c><xref target="unsubscribe"/></c>
       <c>RECONFIRM</c>
       <c>TBA (0x43)</c>
       <c>NO</c>
       <c>Standards Track</c>
       <c><xref target="reconfirm"/></c>
     </texttable>

     <t>This document defines no new DNS OPCODEs or RCODEs.</t>

<?rfc needLines="20" ?>
   </section>

   <section title="Acknowledgements" anchor="Acknowledgements">
     <t>The authors would like to thank Kiren Sekar and Marc Krochmal for previous work completed in this field.</t>

     <t>This draft has been improved due to comments from
     Ran Atkinson,
     Tim Chown,
     Sara Dickinson,
     Mark Delany,
     Ralph Droms,
     Jan Komissar,
     Eric Rescorla,
     Michael Richardson,
     David Schinazi,
     Manju Shankar Rao,
     Robert Sparks,
     Markus Stenberg,
     Andrew Sullivan,
     Michael Sweet,
     Dave Thaler,
     Brian Trammell,
     Bernie Volz,
     Eric Vyncke,
     Christopher Wood,
     Liang Xia,
     and
     Soraia Zlatkovic.
     Ted Lemon provided clarifying text that was greatly appreciated.</t>
<?rfc needLines="15" ?>
   </section>
 </middle>

 <!--  *****BACK MATTER ***** -->

 <back>
   <!-- References split into informative and normative -->

   <!-- There are 2 ways to insert reference entries from the citation libraries:
    1. define an ENTITY at the top, and use "ampersand character"RFC2629; here (as shown)
    2. simply use a PI "less than character"?rfc include="reference.RFC.2119.xml"?> here
       (for I-Ds: include="reference.I-D.narten-iana-considerations-rfc2434bis.xml")

    Both are cited textually in the same manner: by using xref elements.
    If you use the PI option, xml2rfc will, by default, try to find included files in the same
    directory as the including file. You can also define the XML_LIBRARY environment variable
    with a value containing a set of directories to search.  These can be either in the local
    filing system or remote ones accessed by http (http://domain/dir/... ).-->

   <references title="Normative References">
     &RFC0768;
     &RFC0793;
     &RFC1034;
     &RFC1035;
     &RFC1123;
     &RFC2119;
     &RFC2136;
     &RFC2181;
     &RFC2782;
     &RFC6066;
     <?rfc include="reference.RFC.6335" ?>
     &RFC6895;
     &RFC7673;
     &RFC7766;
     &RFC8174;
     &RFC8446;
     &RFC8490;

     <reference anchor="ST"
     target="http://www.iana.org/assignments/service-names-port-numbers/">
       <front>
         <title>Service Name and Transport Protocol Port Number Registry</title>
         <author/>
         <date/>
       </front>
     </reference>

   </references>

<!-- Use needLines to make sure "Authors' Addresses" line doesn't appear as the last line on the page -->
<?rfc needLines="9" ?>

   <references title="Informative References">
     &RFC2308;
     &RFC3123;
     &RFC4287;
     &RFC4953;
     &RFC5077;
     &RFC6281;
     &RFC6762;
     &RFC6763;
     &RFC6824;
     &RFC6886;
     &RFC6887;
     &RFC7413;
     &RFC7525;
     &RFC7719;
     &RFC7858;
     &RFC8010;
     &RFC8011;

     &I-D.dukkipati-tcpm-tcp-loss-probe;

<reference anchor='LLQ'>
<front>
<title>DNS Long-Lived Queries</title>

<author initials='S' surname='Cheshire' fullname='Stuart Cheshire'>
    <organization />
</author>

<author initials='M' surname='Krochmal' fullname='Marc Krochmal'>
    <organization />
</author>

<date month='March' day='4' year='2019' />

<abstract><t>DNS Long-Lived Queries (LLQ) is a protocol for extending the DNS protocol to support change notification, thus allowing clients to learn about changes to DNS data without polling the server.  From 2007 onwards, LLQ was implemented in Apple products including Mac OS X, Bonjour for Windows, and AirPort wireless base stations.  In 2019, the LLQ protocol was superseded by the IETF Standards Track RFC "DNS Push Notifications", which builds on experience gained with the LLQ protocol to create a superior replacement.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-sekar-dns-llq-03' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-sekar-dns-llq-03.txt' />
</reference>

     &RFC8310;

<reference anchor='DisProx'>
<front>
<title>Discovery Proxy for Multicast DNS-Based Service Discovery</title>

<author initials='S' surname='Cheshire' fullname='Stuart Cheshire'>
    <organization />
</author>

<date month='March' day='24' year='2019' />

<abstract><t>This document specifies a network proxy that uses Multicast DNS to automatically populate the wide-area unicast Domain Name System namespace with records describing devices and services found on the local link.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-dnssd-hybrid-10' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-dnssd-hybrid-10.txt' />
</reference>

     <reference anchor='SYN'>
       <front>
         <title>Defenses Against TCP SYN Flooding Attacks</title>
         <author initials='W.' surname='Eddy' fullname='Wesley Eddy'>
           <organization>Verizon Federal Network Systems</organization>
           <address>
             <email>weddy@grc.nasa.gov</email>
           </address>
         </author>
         <date year='2006' month='December' />
         <keyword>TCP</keyword>
       </front>
       <seriesInfo name="The Internet Protocol Journal," value='Cisco Systems' />
       <seriesInfo name='Volume' value='9' />
       <seriesInfo name='Number' value='4' />
       <format type='PDF' octets='882020' target="http://www.cisco.com/web/about/ac123/ac147/archived_issues/ipj_9-4/ipj_9-4.pdf" />
       <format type='HTML' octets='65566' target="http://www.cisco.com/web/about/ac123/ac147/archived_issues/ipj_9-4/syn_flooding_attacks.html" />
     </reference>

     <reference anchor='obs' target="https://en.wikipedia.org/wiki/Observer_pattern">
       <front>
         <title>Observer Pattern</title>
          <author/>
          <date/>
       </front>
     </reference>

     <reference anchor="XEP0060">
       <front>
         <title>Publish-Subscribe</title>
         <author initials="P." surname="Millard" fullname="Peter Millard">
           <organization/>
           <address>
             <email/>
           </address>
         </author>
         <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
           <organization/>
           <address>
             <email>peter@andyet.net</email>
           </address>
         </author>
         <author initials="R." surname="Meijer" fullname="Ralph Meijer">
           <organization/>
           <address>
             <email>ralphm@ik.nu</email>
           </address>
         </author>
         <date day="01" month="July" year="2010"/>
       </front>
       <seriesInfo name="XSF XEP" value="0060"/>
       <format type="HTML" target="http://xmpp.org/extensions/xep-0060.html"/>
     </reference>

   </references>
 </back>
</rfc>
