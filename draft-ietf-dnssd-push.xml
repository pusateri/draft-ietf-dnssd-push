<?xml version="1.0" encoding="UTF-8"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
    which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
    There has to be one entity for each item to be referenced.
    An alternate method (rfc include) is described in the references. -->

<!ENTITY RFC0768 SYSTEM  "http://xml.resource.org/public/rfc/bibxml/reference.RFC.0768.xml">
<!ENTITY RFC0793 SYSTEM  "http://xml.resource.org/public/rfc/bibxml/reference.RFC.0793.xml">
<!ENTITY RFC1034 SYSTEM  "http://xml.resource.org/public/rfc/bibxml/reference.RFC.1034.xml">
<!ENTITY RFC1035 SYSTEM  "http://xml.resource.org/public/rfc/bibxml/reference.RFC.1035.xml">
<!ENTITY RFC1123 SYSTEM  "http://xml.resource.org/public/rfc/bibxml/reference.RFC.1123.xml">
<!ENTITY RFC1996 SYSTEM  "http://xml.resource.org/public/rfc/bibxml/reference.RFC.1996.xml">
<!ENTITY RFC2119 SYSTEM  "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC2136 SYSTEM  "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2136.xml">
<!ENTITY RFC2782 SYSTEM  "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2782.xml">
<!ENTITY RFC4287 SYSTEM  "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4287.xml">
<!ENTITY RFC5246 SYSTEM  "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml">
<!ENTITY RFC5966 SYSTEM  "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5966.xml">
<!ENTITY RFC6066 SYSTEM  "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6066.xml">
<!ENTITY RFC6195 SYSTEM  "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6195.xml">
<!ENTITY RFC6762 SYSTEM  "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6762.xml">
<!ENTITY RFC6763 SYSTEM  "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6763.xml">
<!ENTITY XEP-0060 PUBLIC ""  "http://xmpp.org/extensions/refs/reference.XSF.XEP-0060.xml">
<!ENTITY I-D.ietf-dnssd-hybrid SYSTEM  "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-dnssd-hybrid.xml">
<!ENTITY I-D.sekar-dns-llq SYSTEM  "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.sekar-dns-llq.xml">
<!ENTITY I-D.ietf-uta-tls-bcp SYSTEM  "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-uta-tls-bcp.xml">
<!ENTITY I-D.ietf-tls-tls13 SYSTEM  "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-tls-tls13.xml">
<!ENTITY I-D.ietf-dane-srv SYSTEM  "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-dane-srv.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs),
    please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
    (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space
    (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="std" docName="draft-ietf-dnssd-push-00" ipr="trust200902">
 <!-- category values: std, bcp, info, exp, and historic
    ipr values: trust200902, noModificationTrust200902, noDerivativesTrust200902,
       or pre5378Trust200902
    you can add the attributes updates="NNNN" and obsoletes="NNNN"
    they will automatically be output with "(if approved)" -->

 <!-- ***** FRONT MATTER ***** -->

 <front>
   <!-- The abbreviated title is used in the page header - it is only necessary if the
        full title is longer than 39 characters -->

   <title abbrev="DNS Push Notifications">DNS Push Notifications</title>

   <!-- add 'role="editor"' below for the editors if appropriate -->

   <!-- Another author who claims to be an editor -->

   <author fullname="Tom Pusateri" initials="T.J." surname="Pusateri">
     <organization>Seeking affiliation</organization>

     <address>
       <postal>
         <street></street>
         <!-- Reorder these if your country does things differently -->
         <city>Hilton Head Island</city>
         <region>SC</region>
         <code></code>
         <country>USA</country>
       </postal>
       <phone>+1 843 473 7394</phone>
       <email>pusateri@bangj.com</email>
       <!-- uri and facsimile elements may also be added -->
     </address>
   </author>
   <author fullname="Stuart Cheshire" initials="S." surname="Cheshire">
     <organization>Apple Inc.</organization>

     <address>
       <postal>
         <street>1 Infinite Loop</street>
         <!-- Reorder these if your country does things differently -->
         <city>Cupertino</city>
         <region>CA</region>
         <code>95014</code>
         <country>USA</country>
       </postal>
       <phone>+1 408 974 3207</phone>
       <email>cheshire@apple.com</email>
       <!-- uri and facsimile elements may also be added -->
     </address>
   </author>

   <date year="2015" month="March"/>

   <!-- If the month and year are both specified and are the current ones, xml2rfc will fill
        in the current day for you. If only the current year is specified, xml2rfc will fill
        in the current day and month for you. If the year is not the current one, it is
        necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the
        purpose of calculating the expiry date).  With drafts it is normally sufficient to
        specify just the year. -->

   <!-- Meta-data Declarations -->

   <area>DNSSD</area>

   <workgroup>Internet Engineering Task Force</workgroup>

   <!-- WG name at the upper left corner of the doc,
        IETF is fine for individual submissions.
        If this element is not present, the default is "Network Working Group",
        which is used by the RFC Editor as a nod to the history of the IETF. -->

   <keyword>dns update push notification</keyword>

   <!-- Keywords will be incorporated into HTML output
        files in a meta tag but they have no effect on text or nroff
        output. If you submit your draft to the RFC Editor, the
        keywords will be used for the search engine. -->

   <abstract>
     <t>The Domain Name System (DNS) was designed to efficiently return matching records for queries for data that is relatively static. When those records change frequently, DNS is still efficient at returning the updated results when polled. But there exists no mechanism for a client to be asynchronously notified when these changes occur. This document defines a mechanism for a client to be notified of such changes to DNS records, called DNS Push Notifications.</t>
   </abstract>
 </front>

 <middle>

   <section title="Introduction">
     <t>DNS records may be updated using <xref target="RFC2136">DNS Update</xref>.
     Other mechanisms such as a <xref target="I-D.ietf-dnssd-hybrid">Hybrid Proxy</xref> can also generate changes to a DNS zone.
     This document specifies a protocol for Unicast DNS clients to subscribe to receive asynchronous notifications of changes to RRSets of interest. It is immediately relevant in the case of <xref target="RFC6763">DNS Service Discovery</xref> but is not limited to that use case and provides a general DNS mechanism for DNS record change notifications. Familiarity with the DNS protocol and DNS packet formats is assumed <xref target="RFC1034"/> <xref target="RFC1035"/> <xref target="RFC6195"/>.</t>

     <section title="Requirements Language">
       <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
       "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
       document are to be interpreted as described in
       <xref target="RFC2119">"Key words for use in RFCs to Indicate Requirement Levels"</xref>.</t>
     </section>
   </section>

   <section title="Motivation">
     <t>As the domain name system continues to adapt to new uses and changes in deployment, polling has the potential to burden DNS servers at many levels throughout the network. Other network protocols have successfully deployed a publish/subscribe model to state changes following the Observer design pattern. <xref target="XEP-0060">XMPP Publish-Subscribe</xref> and <xref target="RFC4287">Atom</xref> are examples. While DNS servers are generally highly tuned and capable of a high rate of query/response traffic, adding a publish/subscribe model for tracking changes to DNS records results in more timely notification of changes with reduced CPU usage and network traffic.</t>

     <t><xref target="RFC6762">Multicast DNS</xref> implementations always listen on a well known link-local IP multicast group, and new services and updates are sent for all group members to receive. Therefore, Multicast DNS already has asynchronous change notification capability. However, when <xref target="RFC6763">DNS Service Discovery</xref> is used across a wide area network using Unicast DNS (possibly facilitated via a <xref target="I-D.ietf-dnssd-hybrid">Hybrid Proxy</xref>) it would be beneficial to have an equivalent capability for Unicast DNS, to allow clients to learn about DNS record changes in a timely manner without polling.</t>

     <t><xref target="I-D.sekar-dns-llq">DNS Long-Lived Queries (LLQ)</xref> is an existing deployed UDP-based solution to provide asynchronous change notifications. This document builds on experience gained with that protocol, with an improved design that uses long-lived TCP connections instead of UDP, and adopts the syntax and semantics of <xref target="RFC2136">DNS Update messages</xref> instead of inventing a new vocabulary of messages to communicate DNS zone changes.</t>
<?rfc needLines="20" ?>
   </section>

   <section title="Overview">
     <t>The existing <xref target="RFC2136">DNS Update protocol</xref> provides a mechanism for clients to add or delete individual resource records (RRs) or entire resource record sets (RRSets) on the zone's server. Adopting this existing syntax and semantics for DNS Push Notifications allows for messages going in the other direction, from server to client, to communicate changes to a zone. The client first must subscribe for Push Notifications by connecting to the server and sending DNS message(s) indicating the RRSet(s) of interest. When the client loses interest in updates to these records, it unsubscribes. The DNS Push Notification server for a zone is any server capable of generating the correct change notifications for a name. It may be a master, slave, or stealth name server <xref target="RFC1996"/>.</t>

     <t>DNS Push Notification clients are NOT required to implement DNS Update Prerequisite processing. Prerequisites are used to perform tentative atomic test-and-set type operations on the server, and that concept has no application when it comes to an authoritative server telling a client of changes to DNS records.</t>
   </section>

   <section title="Transport">
     <t>Implementations of <xref target="RFC2136">DNS Update</xref> MAY use either User Datagram Protocol <xref target="RFC0768">(UDP)</xref> or Transmission Control Protocol <xref target="RFC0793">(TCP)</xref> as the transport protocol, in keeping with the historical precedent that DNS queries must first be sent over UDP <xref target="RFC1123"/>. This requirement to use UDP has subsequently been relaxed <xref target="RFC5966"/>. DNS Push Notification is defined only for TCP. DNS Push Notification clients MUST use TCP.</t>

     <t>Either end of the TCP connection can terminate all of the subscriptions on that connection by simply closing the connection abruptly with a TCP RST. (An individual subscription is terminated by sending an UNSUBSCRIBE message for that specific subscription.)</t>

     <t>If a client closes the connection, it is signaling that it is no longer interested in receiving updates to any of the records it has subscribed. It is informing the server that the server may release all state information it has been keeping with regards to this client. This may occur because the client computer has been disconnected from the network, has gone to sleep, or the application requiring the records has terminated.</t>

     <t>If a server closes the connection, it is informing the client that it can no longer provide updates for the subscribed records. This may occur because the server application software or operating system is restarting, the application terminated unexpectedly, the server is undergoing maintenance procedures, or the server is overloaded and can no longer provide the information to all the clients that wish to receive it. The client can try to re-subscribe at a later time or to another DNS server supporting DNS Push Notifications for the zone.</t>

     <t>Transport Layer Security <xref target="RFC5246">(TLS)</xref> is well understood and deployed across many protocols running over TCP. It is designed to prevent eavesdropping, tampering, or message forgery. TLS is REQUIRED for every connection between a client subscriber and server in this protocol specification.</t>

     <t>Connection setup over TCP ensures return reachability and alleviates concerns of state overload at the server through anonymous subscriptions. All subscribers are guaranteed to be reachable by the server by virtue of the TCP three-way handshake. Additional security measures such as authentication during TLS negotiation MAY also be employed to increase the trust relationship between client and server. Because TCP SYN flooding attacks are possible with any protocol over TCP, implementers are encouraged to use industry best practices to guard against such attacks <xref target="IPJ.9-4-TCPSYN"/>.</t>
   </section>

   <section title="State Considerations">
     <t>Each DNS server is capable and handling some finite number of DNS Push Notification subscriptions. This number will vary from DNS server to DNS server and is based on physical machine characteristics, network bandwidth, and operating system resource allocation. After a client establishes a connection to a DNS server, each record subscription is individually accepted or rejected. Servers may employ various techniques to limit subscriptions to a manageable level. Correspondingly, the client is free to establish simultaneous connections to alternate DNS servers that support DNS Push Notifications for the zone and distribute record subscriptions at its discretion. In this way, both clients and servers can react to resource constraints. Token bucket rate limiting schemes are also effective in providing fairness by a server across numerous client requests.</t>
<?rfc needLines="12" ?>
   </section>

   <section title="Protocol Operation">
     <t>A DNS Push Notification exchange begins with the client discovering the appropriate server, and connecting to it. The client may then add and remove Push Notification subscriptions over this connection. In accordance with the current set of active subscriptions the server sends asynchronous Push Notifications to the client. The exchange terminates when either end closes the TCP connection with a TCP RST.</t>

      <section anchor="discovery" title="Discovery">
        <t>The first step in DNS Push Notification subscription is to discover an appropriate DNS server that supports DNS Push Notifications for the desired zone. The client must also determine which TCP port on the server is listening for connections, which need not be (and often is not) the typical TCP port 53 used for conventional DNS.</t>
        <t>
          <list style="numbers">
            <t>The client begins the discovery by sending a DNS query to the local resolver with record type <xref target="RFC1035">SOA</xref> for the name of the record it wishes to subscribe.</t>

            <t>If the SOA record exists, it MUST be returned in the Answer Section of the reply. If not, the server SHOULD include the SOA record for the zone of the requested name in the Authority Section.</t>

            <t>If no SOA record is returned, the client then strips off the leading label from the requested name. If the resulting name has at least one label in it, the client sends a new SOA query and processing continues at step 2 above. If the resulting name is empty (the root label) then this is a network configuration error and the client gives up. The client MAY retry the operation at a later time.</t>

            <t>Once the SOA is known, the client sends a DNS query with type <xref target="RFC2782">SRV</xref> for the record name <spanx style="verb">_dns-push._tcp.&lt;zone&gt;</spanx>, where &lt;zone&gt; is the owner name of the discovered SOA record.</t>

            <t>If the zone in question does not offer DNS Push Notifications then SRV record MUST NOT exist and the SRV query will return a negative answer.</t>

            <t>If the zone in question is set up to offer DNS Push Notifications then this SRV record MUST exist.
            The SRV <spanx style="verb">target</spanx> contains the name of the server providing DNS Push Notifications for the zone. The port number on which to contact the server is in the SRV record <spanx style="verb">port</spanx> field. The address(es) of the target host MAY be included in the Additional Section, however, the address records SHOULD be authenticated before use as described in <xref target="tls_name_auth"/> <xref target="I-D.ietf-dane-srv"/>.</t>

            <t>More than one SRV record may be returned. In this case, the <spanx style="verb">priority</spanx> and <spanx style="verb">weight</spanx> values in the returned SRV records are used to determine the order in which to contact the servers for subscription requests. As described in <xref target="RFC2782">the SRV specification</xref>, the server with the lowest <spanx style="verb">priority</spanx> is first contacted. If more than one server has the same <spanx style="verb">priority</spanx>, the <spanx style="verb">weight</spanx> is indicates the weighted probability that the client should contact that server. Higher weights have higher probabilities of being selected. If a server is not reachable or is not willing to accept a subscription request, then a subsequent server is to be contacted.</t>

          </list>
          If a server closes a DNS Push Notification subscription connection, the client SHOULD repeat the discovery process in order to determine the preferred DNS server for subscriptions at that time.
        </t>
     </section>

     <section title="DNS Push Notification SUBSCRIBE">
       <t>A DNS Push Notification client indicates its desire to receive DNS Push Notifications for a given domain name by sending a SUBSCRIBE message over the established TCP connection to the server. A SUBSCRIBE message is formatted identically to a conventional <xref target="RFC1035">DNS QUERY message</xref>, except that the opcode is SUBSCRIBE (6) instead of QUERY (0). If neither QTYPE nor QCLASS are ANY (255) then this is a specific subscription to changes for the given name, type and class. If one or both of QTYPE or QCLASS are ANY (255) then this is a wildcard subscription to changes for the given name for any type and/or class, as appropriate.</t>

       <t>Like a DNS QUERY message, a SUBSCRIBE message MUST contain exactly one question. Since SUBSCRIBE messages are sent over TCP, multiple SUBSCRIBE messages can be concatenated in a single TCP stream and packed efficiently into TCP segments, so the ability to pack multiple SUBSCRIBE operations into a single DNS message within that TCP stream is not compelling.</t>

       <t>The RCODE in the SUBSCRIBE response indicates whether or not the subscription was accepted.
       The Answer Section MUST be empty. If the subscription was accepted and the there are positive answers for the requested name, type and class, then these positive answers MUST be communicated to the client in an immediately following Push Notification Update, not in the Answer Section of the SUBSCRIBE response.
       This simplifying requirement is made so that there is only a single way that information is communicted to a DNS Push Notification client. Since a DNS Push Notification client has to parse information received via Push Notification Updates anyway, it is simpler if it does not also have to parse information received via the Answer Section of a SUBSCRIBE response.</t>

       <t>Supported RCODEs are as follows:</t>
       <texttable anchor="table_update_rcodes" title="Response codes">
       <ttcol align="left">Mneumonic</ttcol>
       <ttcol align="center">Value</ttcol>
       <ttcol align="left">Description</ttcol>
       <c>NOERROR</c><c>0</c><c>SUBSCRIBE successful</c>
       <c>FORMERR</c><c>1</c><c>Server failed to process request due to a malformed request</c>
       <c>SERVFAIL</c><c>2</c><c>Server failed to process request due to resource exhaustion</c>
       <c>NOTIMP</c><c>4</c><c>Server does not implement DNS Push Notifications</c>
       <c>REFUSED</c><c>5</c><c>Server refuses to process request for policy or security reasons</c>
       </texttable>

       <t>If accepted, the subscription will stay in effect until the client revokes the subscription or until the connection between the client and the server is closed.</t>

       <t>A client MUST not send a SUBSCRIBE message that duplicates the name, type and class of an existing active subscription. For the purpose of this matching, the established DNS case-insensitivity for US-ASCII letters applies (e.g., "foo.com" and "Foo.com" are the same). If a server receives such a duplicate SUBSCRIBE message this is an error and the server MUST immediately close the TCP connection.</t>

       <t>Wildcarding is not supported. That is, a wildcard ("*") in a SUBSCRIBE message matches only a wildcard ("*") in the zone, and nothing else.</t>

       <t>Aliasing is not supported. That is, a CNAME in a SUBSCRIBE message matches only a CNAME in the zone, and nothing else.</t>

       <t>Note that a client may SUBSCRIBE to records that are unknown to the server at the time of the requesta and this is not an error. The server MUST accept these requests and send Push Notifications if and when matches are found in the future.</t>
     </section>

     <section title="DNS Push Notification UNSUBSCRIBE">
       <t>To cancel an individual subscription without closing the entire connection, the client sends an UNSUBSCRIBE message over the established TCP connection to the server. The UNSUBSCRIBE message is formatted identically to the SUBSCRIBE message which created the subscription, with the exact same name, type and class, except that the opcode is UNSUBSCRIBE (7) instead of SUBSCRIBE (6).</t>

       <t>A client MUST not send an UNSUBSCRIBE message that does not exactly match the name, type and class of an existing active subscription. If a server receives such an UNSUBSCRIBE message this is an error and the server MUST immediately close the TCP connection.</t>

       <t>No response message is generated as a result of processing an UNSUBSCRIBE message.</t>

       <t>Having being sucessfully revoked with a correctly-formatted UNSUBSCRIBE message, the previously referenced subscription is no longer active and the server MAY discard the state associated with it immediately, or later, at the server's discretion.</t>
<?rfc needLines="28" ?>
     </section>

     <section title="DNS Push Notification Update Messages">
       <t>Once a subscription has been sucessfully established, the server generates Push Notification Updates to send to the client as appropriate. An initial Push Notification Update will be sent immediately in the case that the answer set was non-empty at the moment the subscription was established. Subsequent changes to the answer set are then communicated in subsequent Push Notification Updates.</t>

       <t>The format of Push Notification Updates borrows from the existing <xref target="RFC2136">DNS Update</xref> protocol, with some simplifications.</t>
       <t>The following figure shows the existing DNS header Update format:
       <figure align="center" anchor="packet_header"><artwork align="center"><![CDATA[
                                1  1  1  1  1  1
  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                      ID                       |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|QR|   Opcode  |          Z         |   RCODE   |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                    ZOCOUNT                    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                    PRCOUNT                    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                    UPCOUNT                    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                    ADCOUNT                    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
               ]]></artwork>
       </figure>
       </t>

       <t>For DNS Push Notifications, ZOCOUNT MUST be zero, and the Zone Section MUST be empty.</t>

       <t>For DNS Push Notifications, PRCOUNT MUST be zero, and the Prerequesite Section MUST be empty.</t>

       <t>For DNS Push Notifications, ADCOUNT MUST be zero, and the Additional Data Section MUST be empty.</t>

<?rfc needLines="15" ?>
       <t>For DNS Push Notifications, the Update Section contains the relevant change information for the client, formatted identically to a <xref target="RFC2136">DNS Update</xref>. To recap:
         <list style="bullets">
           <t>Delete all RRsets from a name: TTL=0, CLASS=ANY, RDLENGTH=0, TYPE=ANY.</t>
           <t>Delete an RRset from a name: TTL=0, CLASS=ANY, RDLENGTH=0; TYPE specifies the RRset being deleted.</t>
           <t>Delete an individual RR from a name: TTL=0, CLASS=NONE; TYPE, RDLENGTH and RDATA specifies the individual RR being deleted.</t>
           <t>Add an individual RR to a name: TTL, CLASS, TYPE, RDLENGTH and RDATA specifies the RR being added.</t>
         </list>
       </t>

       <t>Upon reception of a Push Notification Update Message, the client receiving the message MUST validate that the records being added or deleted correspond with at least one currently active subscription on that connection. Specifically, the record name MUST match the name given in the SUBSCRIBE request, subject to the usual established DNS case-insensitivity for US-ASCII letters.
       If the QTYPE was not ANY (255) then the TYPE of the record must match the QTYPE given in the SUBSCRIBE request.
       If the QCLASS was not ANY (255) then the CLASS of the record must match the QCLASS given in the SUBSCRIBE request.
       If a matching active subscription on that connection is not found, then that individual record addition/deletion is silently ignored. Processing of other additions and deletions in this message is not affected. The TCP connection is not closed. This is to allow for the race condition where a client sends an UNSUBSCRIBE while Push Notification Updates for that subscription are still in flight from the server.</t>

       <t>In the case where a single change affects more than one active subscription, only one update is sent. For example, an update adding a given record may match both a SUBSCRIBE request with the same QTYPE and a different SUBSCRIBE request with QTYPE=ANY. Two updates are not sent because the new record matches two active subscription.</t>

       <t>Successful handling of a Push Notification Update Message results in no response back to the server.</t>

       <t>The TTL of an added record is stored by the client and decremented as time passes, with the caveat that for as long as a relevant subscription is active, the TTL does not decrement below 1 second. For as long as a relevant subscription remains active, the client SHOULD assume that when a record goes away the server will notify it of that fact. Consequently, a client does not have to poll to verify that the record is still there. Once a subscription is cancelled (individually, or as a result of the TCP connection being closed) record aging contines and records are removed from the local cache when their TTL reaches zero.</t>

     </section>
<?rfc needLines="10" ?>
   </section>

   <section anchor="Acknowledgements" title="Acknowledgements">
     <t>The authors would like to thank Kiren Sekar and Marc Krochmal for previous work completed in this field. This draft has been improved due to comments from Ran Atkinson.</t>
<?rfc needLines="8" ?>
   </section>

   <section anchor="IANA" title="IANA Considerations">
     <t>This document defines the service name: <spanx style="verb">_dns-push._tcp</spanx>. It is only applicable for the TCP protocol. This name is to be published in the IANA Service Name Registry.</t>
     <t>This document defines two DNS OpCodes: SUBSCRIBE with (tentative) value 6 and UNSUBSCRIBE with (tentative) value 7.</t>
   </section>

   <section anchor="Security" title="Security Considerations">
     <t>Strict TLS support is mandatory in DNS Push Notifications. There is no provision for opportunistic encryption using a mechanism like <spanx style="verb">STARTTLS</spanx>.</t>
     <section title="Security Services">
       <t>It is the goal of using TLS to provide the following security services:
         <list style="hanging">
           <t hangText="Confidentiality">All application-layer communication is encrypted with the goal that no party should be able to decrypt it except the intended receiver.</t>
           <t hangText="Data integrity protection">Any changes made to the communication in transit are detectable by the receiver.</t>
           <t hangText="Authentication">An end-point of the TLS communication is authenticated as the intended entity to communicate with.</t>
         </list>
       </t>
       <t>Deployment recommendations on the appropriate key lengths and cypher suites are beyond the scope of this document. Please refer to <xref target="I-D.ietf-uta-tls-bcp">TLS Recommendations</xref> for the best current practices. Keep in mind that best practices only exist for a snapshot in time and recommendations will continue to change. Updated versions or errata may exist for these recommendations.</t>
     </section>

     <section anchor="tls_name_auth" title="TLS Name Authentication">
       <t>As described in <xref target="discovery"/>, the client discovers the DNS Push Notification server using an SRV lookup for the record name <spanx style="verb">_dns-push._tcp.&lt;zone&gt;</spanx>. The server connection endpoint SHOULD then be authenticated using DANE TLSA records for the associated SRV record. This associates the target's name and port number with a trusted TLS certificate <xref target="I-D.ietf-dane-srv"/>. This procedure uses the TLS Sever Name Indication (SNI) extension <xref target="RFC6066"/> to inform the server of the name the client has authenticated through the use of TLSA records.</t>
     </section>

     <section title="TLS Compression">
       <t>In order to reduce the chances of compression related attacks, TLS-level compression SHOULD be disabled when using TLS versions 1.2 and earlier. In the draft version of <xref target="I-D.ietf-tls-tls13">TLS 1.3</xref>, TLS-level compression has been removed completely.</t>
     </section>

     <section title="TLS Session Resumption">
       <t>TLS Session Resumption MUST be disabled on DNS Push Notification servers. It is not useful to have subscription state cached for long periods of time. It is also not desirable for subscription state to be maintained while the client is not connected.</t>
     </section>
   </section>
 </middle>

 <!--  *****BACK MATTER ***** -->

 <back>
   <!-- References split into informative and normative -->

   <!-- There are 2 ways to insert reference entries from the citation libraries:
    1. define an ENTITY at the top, and use "ampersand character"RFC2629; here (as shown)
    2. simply use a PI "less than character"?rfc include="reference.RFC.2119.xml"?> here
       (for I-Ds: include="reference.I-D.narten-iana-considerations-rfc2434bis.xml")

    Both are cited textually in the same manner: by using xref elements.
    If you use the PI option, xml2rfc will, by default, try to find included files in the same
    directory as the including file. You can also define the XML_LIBRARY environment variable
    with a value containing a set of directories to search.  These can be either in the local
    filing system or remote ones accessed by http (http://domain/dir/... ).-->

   <references title="Normative References">
     &I-D.ietf-dane-srv;
     &I-D.ietf-tls-tls13;
     &I-D.ietf-uta-tls-bcp;
     &RFC0768;
     &RFC0793;
     &RFC1034;
     &RFC1035;
     &RFC1123;
     &RFC2119;
     &RFC2136;
     &RFC2782;
     &RFC5246;
     &RFC5966;
     &RFC6066;
     &RFC6195;
   </references>

   <references title="Informative References">

     &I-D.sekar-dns-llq;
     &I-D.ietf-dnssd-hybrid;
     &RFC1996;
     &RFC4287;
     &RFC6762;
     &RFC6763;
     &XEP-0060;

     <reference anchor='IPJ.9-4-TCPSYN'>
       <front>
         <title>Defenses Against TCP SYN Flooding Attacks</title>
         <author initials='W.' surname='Eddy' fullname='Wesley Eddy'>
           <organization>Verizon Federal Network Systems</organization>
           <address>
             <email>weddy@grc.nasa.gov</email>
           </address>
         </author>
         <date year='2006' month='December' />
         <keyword>TCP</keyword>
       </front>
       <seriesInfo name="The Internet Protocol Journal," value='Cisco Systems' />
       <seriesInfo name='Volume' value='9' />
       <seriesInfo name='Number' value='4' />
       <format type='PDF' octets='882020' target="http://www.cisco.com/web/about/ac123/ac147/archived_issues/ipj_9-4/ipj_9-4.pdf" />
       <format type='HTML' octets='65566' target="http://www.cisco.com/web/about/ac123/ac147/archived_issues/ipj_9-4/syn_flooding_attacks.html" />
     </reference>

   </references>

   <!-- Change Log
v00 2015-02-28  TJP   Initial version
  -->
 </back>
</rfc>
