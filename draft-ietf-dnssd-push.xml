<?xml version="1.0" encoding="UTF-8"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
    which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
    There has to be one entity for each item to be referenced.
    An alternate method (rfc include) is described in the references. -->

<!ENTITY RFC0768 SYSTEM  "http://xml.resource.org/public/rfc/bibxml/reference.RFC.0768.xml">
<!ENTITY RFC0793 SYSTEM  "http://xml.resource.org/public/rfc/bibxml/reference.RFC.0793.xml">
<!ENTITY RFC1034 SYSTEM  "http://xml.resource.org/public/rfc/bibxml/reference.RFC.1034.xml">
<!ENTITY RFC1035 SYSTEM  "http://xml.resource.org/public/rfc/bibxml/reference.RFC.1035.xml">
<!ENTITY RFC1123 SYSTEM  "http://xml.resource.org/public/rfc/bibxml/reference.RFC.1123.xml">
<!ENTITY RFC1996 SYSTEM  "http://xml.resource.org/public/rfc/bibxml/reference.RFC.1996.xml">
<!ENTITY RFC2119 SYSTEM  "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC2136 SYSTEM  "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2136.xml">
<!ENTITY RFC2782 SYSTEM  "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2782.xml">
<!ENTITY RFC4287 SYSTEM  "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4287.xml">
<!ENTITY RFC4953 SYSTEM  "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4953.xml">
<!ENTITY RFC5077 SYSTEM  "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5077.xml">
<!ENTITY RFC5246 SYSTEM  "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml">
<!ENTITY RFC6066 SYSTEM  "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6066.xml">
<!ENTITY RFC6891 SYSTEM  "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6891.xml">
<!ENTITY RFC6895 SYSTEM  "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6895.xml">
<!ENTITY RFC6762 SYSTEM  "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6762.xml">
<!ENTITY RFC6763 SYSTEM  "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6763.xml">
<!ENTITY RFC7525 SYSTEM  "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7525.xml">
<!ENTITY RFC7673 SYSTEM  "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7673.xml">
<!ENTITY RFC7766 SYSTEM  "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7766.xml">
<!ENTITY I-D.sekar-dns-llq SYSTEM  "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.sekar-dns-llq.xml">
<!ENTITY I-D.ietf-tls-tls13 SYSTEM  "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-tls-tls13.xml">
<!ENTITY I-D.ietf-dnsop-edns-tcp-keepalive SYSTEM  "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-dnsop-edns-tcp-keepalive.xml">
<!ENTITY I-D.ietf-dprive-dns-over-tls SYSTEM  "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-dprive-dns-over-tls.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs),
    please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
    (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space
    (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="std" docName="draft-ietf-dnssd-push-07" ipr="trust200902">
 <!-- category values: std, bcp, info, exp, and historic
    ipr values: trust200902, noModificationTrust200902, noDerivativesTrust200902,
       or pre5378Trust200902
    you can add the attributes updates="NNNN" and obsoletes="NNNN"
    they will automatically be output with "(if approved)" -->

 <!-- ***** FRONT MATTER ***** -->

 <front>
   <!-- The abbreviated title is used in the page header - it is only necessary if the
        full title is longer than 39 characters -->

   <title abbrev="DNS Push Notifications">DNS Push Notifications</title>

   <!-- add 'role="editor"' below for the editors if appropriate -->

   <!-- Another author who claims to be an editor -->

   <author fullname="Tom Pusateri" initials="T.J." surname="Pusateri">
     <organization>Seeking affiliation</organization>

     <address>
       <postal>
         <street></street>
         <!-- Reorder these if your country does things differently -->
         <city>Hilton Head Island</city>
         <region>SC</region>
         <code></code>
         <country>USA</country>
       </postal>
       <phone>+1 843 473 7394</phone>
       <email>pusateri@bangj.com</email>
       <!-- uri and facsimile elements may also be added -->
     </address>
   </author>
   <author fullname="Stuart Cheshire" initials="S." surname="Cheshire">
     <organization>Apple Inc.</organization>

     <address>
       <postal>
         <street>1 Infinite Loop</street>
         <!-- Reorder these if your country does things differently -->
         <city>Cupertino</city>
         <region>CA</region>
         <code>95014</code>
         <country>USA</country>
       </postal>
       <phone>+1 408 974 3207</phone>
       <email>cheshire@apple.com</email>
       <!-- uri and facsimile elements may also be added -->
     </address>
   </author>

   <date day='4' month='April' year='2016'/>

   <!-- If the month and year are both specified and are the current ones, xml2rfc will fill
        in the current day for you. If only the current year is specified, xml2rfc will fill
        in the current day and month for you. If the year is not the current one, it is
        necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the
        purpose of calculating the expiry date).  With drafts it is normally sufficient to
        specify just the year. -->

   <!-- Meta-data Declarations -->

   <area>DNSSD</area>

   <workgroup>Internet Engineering Task Force</workgroup>

   <!-- WG name at the upper left corner of the doc,
        IETF is fine for individual submissions.
        If this element is not present, the default is "Network Working Group",
        which is used by the RFC Editor as a nod to the history of the IETF. -->

   <keyword>dns update push notification</keyword>

   <!-- Keywords will be incorporated into HTML output
        files in a meta tag but they have no effect on text or nroff
        output. If you submit your draft to the RFC Editor, the
        keywords will be used for the search engine. -->

   <abstract>
     <t>The Domain Name System (DNS) was designed to return matching records efficiently for queries for data that is relatively static. When those records change frequently, DNS is still efficient at returning the updated results when polled. But there exists no mechanism for a client to be asynchronously notified when these changes occur. This document defines a mechanism for a client to be notified of such changes to DNS records, called DNS Push Notifications.</t>
   </abstract>
 </front>

 <middle>

   <section title="Introduction">
     <t>DNS records may be updated using <xref target="RFC2136">DNS Update</xref>.
     Other mechanisms such as a <xref target="I-D.ietf-dnssd-hybrid">Hybrid Proxy</xref> can also generate changes to a DNS zone.
     This document specifies a protocol for Unicast DNS clients to subscribe to receive asynchronous notifications of changes to RRSets of interest. It is immediately relevant in the case of <xref target="RFC6763">DNS Service Discovery</xref> but is not limited to that use case, and provides a general DNS mechanism for DNS record change notifications. Familiarity with the DNS protocol and DNS packet formats is assumed <xref target="RFC1034"/> <xref target="RFC1035"/> <xref target="RFC6895"/>.</t>

<?rfc needLines="7" ?>
     <section title="Requirements Language">
       <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
       "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this
       document are to be interpreted as described in
       <xref target="RFC2119">"Key words for use in RFCs to Indicate Requirement Levels"</xref>.</t>

     </section>
   </section>

   <section title="Motivation">
     <t>As the domain name system continues to adapt to new uses and changes in deployment, polling has the potential to burden DNS servers at many levels throughout the network. Other network protocols have successfully deployed a publish/subscribe model to state changes following the Observer design pattern. <xref target="XEP0060">XMPP Publish-Subscribe</xref> and <xref target="RFC4287">Atom</xref> are examples. While DNS servers are generally highly tuned and capable of a high rate of query/response traffic, adding a publish/subscribe model for tracking changes to DNS records can result in more timely notification of changes with reduced CPU usage and lower network traffic.</t>

     <t><xref target="RFC6762">Multicast DNS</xref> implementations always listen on a well known link-local IP multicast group, and new services and updates are sent for all group members to receive. Therefore, Multicast DNS already has asynchronous change notification capability. However, when <xref target="RFC6763">DNS Service Discovery</xref> is used across a wide area network using Unicast DNS (possibly facilitated via a <xref target="I-D.ietf-dnssd-hybrid">Hybrid Proxy</xref>) it would be beneficial to have an equivalent capability for Unicast DNS, to allow clients to learn about DNS record changes in a timely manner without polling.</t>

     <t><xref target="I-D.sekar-dns-llq">DNS Long-Lived Queries (LLQ)</xref> is an existing deployed solution to provide asynchronous change notifications. Even though it can be used over TCP, LLQ is defined primarily as a UDP-based protocol, and as such it defines its own equivalents of existing TCP features like the three-way handshake. This document builds on experience gained with the LLQ protocol, with an improved design that uses long-lived TCP connections instead of UDP (and therefore doesn't need to duplicate existing TCP functionality), and adopts the syntax and semantics of <xref target="RFC2136">DNS Update messages</xref> instead of inventing a new vocabulary of messages to communicate DNS zone changes.</t>

     <t>Because DNS Push Notifications impose a certain load on the responding server (though less load than rapid polling of that server) DNS Push Notification clients SHOULD exercise restraint in issuing DNS Push Notification subscriptions. A subscription SHOULD only be active when there is a valid reason to need live data (for example, an on-screen display is currently showing the results of that subscription to the user) and the subscription SHOULD be cancelled as soon as the need for that data ends (for example, when the user dismisses that display). Implementations MAY want to implement idle timeouts, so that if the user ceases interacting with the device, the display showing the result of the DNS Push Notification subscription is automatically dismissed after a certain period of inactivity. For example, if a user presses the "Print" button on their phone, and then leaves the phone showing the printer discovery screen until the phone goes to sleep, then the printer discovery screen should be automatically dismissed as the device goes to sleep. If the user does still intend to print, this will require them to press the "Print" button again when they wake their phone up.</t>

     <t>A DNS Push Notification client MUST NOT routinely keep a DNS Push Notification subscription active 24 hours a day 7 days a week just to keep a list in memory up to date so that it will be really fast if the user does choose to bring up an on-screen display of that data. DNS Push Notifications are designed to be fast enough that there is no need to pre-load a "warm" list in memory just in case it might be needed later.</t>

     <t>Generally, a client SHOULD NOT keep a connection to a server open indefinitely if it has no active subscriptions on that connection. After 30 seconds with no active subscriptions the client SHOULD close the idle connection, and, if needed in the future, open a new connection.</t>

<?rfc needLines="2" ?>
   </section>

   <section title="Overview">
     <t>The existing <xref target="RFC2136">DNS Update protocol</xref> provides a mechanism for clients to add or delete individual resource records (RRs) or entire resource record sets (RRSets) on the zone's server.</t>

     <t>This specification adopts a simplified subset of these existing syntax and semantics, and uses them for DNS Push Notification messages going in the opposite direction, from server to client, to communicate changes to a zone. The client subscribes for Push Notifications by connecting to the server and sending DNS message(s) indicating the RRSet(s) of interest. When the client loses interest in updates to these records, it unsubscribes.</t>

     <t>The DNS Push Notification server for a zone is any server capable<vspace />
     of generating the correct change notifications for a name.<vspace />
     It may be a master, slave, or stealth name server <xref target="RFC1996"/>.
     Consequently, the <spanx style="verb">_dns&nbhy;push&nbhy;tls._tcp.&lt;zone&gt;</spanx> SRV record for a<vspace />
     zone MAY reference the same target host and port as that zone's
     <spanx style="verb">_dns&nbhy;update&nbhy;tls._tcp.&lt;zone&gt;</spanx> SRV record. When the same target host and port is offered for both DNS Updates and DNS Push Notifications, a client MAY use a single TCP connection to that server for both DNS Updates and DNS Push Notification Queries.</t>

     <t>Supporting DNS Updates and DNS Push Notifications on the same server is OPTIONAL. A DNS Push Notification server is not REQUIRED to support DNS Update.</t>

     <t>DNS Updates and DNS Push Notifications may be handled on different ports on the same target host, in which case they are not considered to be the "same server" for the purposes of this specification, and communications with these two ports are handled independently.</t>

     <t>Standard DNS Queries MAY be sent over a DNS Push Notification connection, provided that these are queries for names falling within the server's zone (the &lt;zone&gt; in the <spanx style="verb">_dns&nbhy;push&nbhy;tls._tcp.&lt;zone&gt;</spanx> SRV record). The RD (Recursion Desired) bit MUST be zero.</t>

     <t>DNS Push Notification clients are NOT required to implement DNS Update Prerequisite processing. Prerequisites are used to perform tentative atomic test-and-set type operations when a client updates records on a server, and that concept has no applicability when it comes to an authoritative server informing a client of changes to DNS records.</t>

     <t>This DNS Push Notification specification includes support for DNS classes, for completeness. However, in practice, it is anticipated that for the foreseeable future the only DNS class in use will be DNS class "IN", as it is today with existing DNS servers and clients. A DNS Push Notification server MAY choose to implement only DNS class "IN".</t>
<?rfc needLines="24" ?>
   </section>

   <section title="Transport">
     <t>Implementations of <xref target="RFC2136">DNS Update</xref> MAY use either User Datagram Protocol <xref target="RFC0768">(UDP)</xref> or Transmission Control Protocol <xref target="RFC0793">(TCP)</xref> as the transport protocol, in keeping with the historical precedent that DNS queries must first be sent over UDP <xref target="RFC1123"/>. This requirement to use UDP has subsequently been relaxed <xref target="RFC7766"/>.</t>

     <t>In keeping with the more recent precedent, DNS Push Notification is defined only for TCP. DNS Push Notification clients MUST use TLS over TCP.</t>

     <t>Connection setup over TCP ensures return reachability and alleviates concerns of state overload at the server through anonymous subscriptions. All subscribers are guaranteed to be reachable by the server by virtue of the TCP three-way handshake. Because TCP SYN flooding attacks are possible with any protocol over TCP, implementers are encouraged to use industry best practices to guard against such attacks <xref target="IPJ.9-4-TCPSYN"/> <xref target="RFC4953"/>.</t>

     <t>Transport Layer Security <xref target="RFC5246">(TLS)</xref> is well understood and deployed across many protocols running over TCP. It is designed to prevent eavesdropping, tampering, or message forgery. TLS is REQUIRED for every connection between a client subscriber and server in this protocol specification. Additional security measures such as client authentication during TLS negotiation MAY also be employed to increase the trust relationship between client and server. Additional authentication of the SRV target using DNSSEC verification and DANE TLSA records <xref target="RFC7673"/> is strongly encouraged. See below in <xref target="tls_name_auth"/> for details.</t>

     <t>A DNS Push Notification session begins with a client connecting to a DNS Push Notification server. Over that connection the client then issues DNS operation requests, such as SUBSCRIBE.</t>

<?rfc needLines="18" ?>
     <section title="Client-Initiated Termination">

       <t>An individual subscription is terminated by sending an UNSUBSCRIBE message for that specific subscription, or all subscriptions can be cancelled at once by the client closing the connection. When a client terminates an individual subscription (via UNSUBSCRIBE) or all subscriptions on that connection (by closing the connection) it is signalling to the server that it is longer interested in receiving those particular updates. It is informing the server that the server may release any state information it has been keeping with regards to these particular subscriptions.</t>

       <t>After terminating its last subscription on a connection via UNSUBSCRIBE, a client MAY close the connection immediately, or it may keep it open if it anticipates performing further operations on that connection in the future. If a client wishes to keep an idle connection open, it MUST continue to meet its keepalive obligations
       <xref target="I-D.ietf-dnsop-edns-tcp-keepalive"/> or the server is entitled to close the connection (see below).</t>

       <t>If a client plans to terminate one or more subscriptions on a connection and doesn't intend to keep that connection open, then as an efficiency optimization it MAY instead choose to simply close the connection, which implicitly terminates all subscriptions on that connection. This may occur because the client computer is being shut down, is going to sleep, the application requiring the subscriptions has terminated, or simply because the last active subscription on that connection has been cancelled.</t>

       <t>When closing a connection, a client will generally do an abortive disconnect, sending a TCP RST. This immediately discards all remaining inbound and outbound data, which is appropriate if the client no longer has any interest in this data. In the BSD sockets API, sending a TCP RST is achieved by setting the SO_LINGER option with a time of 0 seconds and then closing the socket.</t>

       <t>If a client has performed operations on this connection that it would not want lost (like DNS updates) then the client SHOULD do an orderly disconnect, sending a TCP FIN. In the BSD sockets API, sending a TCP FIN is achieved by calling "shutdown(s,SHUT_WR)" and keeping the socket open until all remaining data has been read from it.</t>

       <t>In the first SUBSCRIBE response on a connection, the server MUST include an explicit EDNS(0) TCP Keepalive option. If the first SUBSCRIBE response does not include an explicit EDNS(0) TCP Keepalive option this is an error and the client MUST immediately close the TCP connection and not attempt any further DNS Push Notification requests to that server until one hour has passed. This situation may occur if a client connects to a server that doesn't implement DNS Push Notifications at all, and it is important not to burden such servers with continuous retries.</t>

       <t>Upon receiving an error response from the server, a client SHOULD NOT close the connection. An error relating to one particular operation on a connection does not necessarily imply that all other operations on that connection have also failed, or that future operations will fail. The client should assume that the server will make its own decision about whether or not to close the connection, based on the server's determination of whether the error condition pertains to this particular operation, or would also apply to any subsequent operations. If the server does not close the connection then the client SHOULD continue to use that connection for subsequent operations.</t>

       <t>Upon receiving a Termination Message from the server (see below), a client MUST immediately close the connection.</t>

<?rfc needLines="38" ?>
     </section>

     <section title="Server-Initiated Termination">

       <t>If a client makes a connection and then fails to send any DNS message that uses EDNS(0) TCP Keepalive
       <xref target="I-D.ietf-dnsop-edns-tcp-keepalive"/> (either SUBSCRIBE, where Keepalive is implicit, or some other DNS message, with an explicit an EDNS(0) TCP Keepalive option) then after 30 seconds of inactivity the server SHOULD close the connection. If no data has been sent on the connection the server MAY abort the connection with a TCP RST. If data has been sent on the connection then the server SHOULD close the connection gracefully with a TCP FIN so that the data is reliably delivered.</t>

       <t>In the response to the first successful SUBSCRIBE, the included EDNS(0) TCP Keepalive option specifies the idle timeout so that the client knows the frequency of traffic it must generate to keep the connection alive. If the idle timeout for that connection changes, then the server communicates this by placing an updated EDNS(0) TCP Keepalive option in a subsequent message to the client.</t>

       <t>At both servers and clients, the generation or reception of any complete request, response, update, or keepalive message resets the keepalive timer for that connection.</t>

       <t>In the absence of any requests, responses, or update messages on a connection, a client MUST generate keepalive traffic before the idle timeout expires, or the server is entitled to close the connection.</t>

       <t>If a client disconnects from the network abruptly, without closing its connection, the server learns of this after failing to receive further traffic from that client. If no requests, responses, update messages or keepalive traffic occurs on a connection for 1.5 times the idle timeout, then this indicates that the client is probably no longer on the network, and the server SHOULD abort the connection with a TCP RST. The time before the server closes the connection is intentionally 50% longer than the time before the client is required to generate keepalive traffic, to allow for differences in clock rate and network propagation delays.</t>

       <t>[We need to discuss the nature of "the required keepalives". Are they TCP-layer keepalives? DNS-layer keepalives? There is currently no DNS-layer keepalive or 'no-op' operation defined. What would that operation be? A DNS QUERY containing zero questions? A DNS SUBSCRIBE containing zero questions? An "empty" DNS message over the TCP connection (just a pair of zero bytes, signifying a zero-length message)? One benefit of TCP-layer keepalives is that they transmit fewer bytes, and involve less software overhead for processing those bytes. Another benefit is that it is more feasible to implement these in networking offload hardware, which can allow devices to meet their TCP keepalive obligations while sleeping. This is particularly important for battery-powered devices like mobile phones and tablets. On the other hand, using TCP-layer keepalives requires an API for a client to tell the networking stack at what frequency to perform TCP-layer keepalives, and an API for a server to request the networking stack to inform it when TCP-layer keepalives are not received by the required deadline. TCP-layer keepalives also only verify liveness of the remote networking stack, whereas DNS-layer keepalives provide higher assurance of liveness of the remote server application software -- though this a limited benefit, since there is no reason to expect that DNS Push Notification server software will routinely become wedged and unresponsive.]</t>

       <t>After sending an error response to a client, the server MAY close the connection with a TCP FIN, or may allow the connection to remain open. For error conditions that only affect the single operation in question, the server SHOULD return an error response to the client and leave the connection open for further operations. For error conditions that are likely to make all operations unsuccessful in the immediate future, the server SHOULD return an error response to the client and then close the connection with a TCP FIN.</t>

       <t>If the server is overloaded and needs to shed load, it SHOULD send a Termination Message to the client and close the connection with a TCP FIN.</t>

       <t>Apart from the cases described above, a server MUST NOT close a connection with a DNS Push Notification client, except in extraordinary error conditions. Closing the connection is the client's responsibility, to be done at the client's discretion, when it so chooses. A DNS Push Notification server only closes a DNS Push Notification connection under exceptional circumstances, such as when the server application software or underlying operating system is restarting, the server application terminated unexpectedly (perhaps due to a bug that makes it crash), or the server is undergoing maintenance procedures. When possible, a DNS Push Notification server SHOULD send a Termination Message (<xref target="termination"/> ) informing the client of the reason for the connection being closed.</t>

       <t>After a connection is closed by the server, the client SHOULD try to reconnect, to that server, or to another server supporting DNS Push Notifications for the zone. If reconnecting to the same server, and there was a Termination Message or error response containing a EDNS(0) TCP Keepalive option, the client MUST respect the indicated delay before attempting to reconnect.</t>

<?rfc needLines="18" ?>
     </section>
   </section>

   <section title="State Considerations">
     <t>Each DNS Push Notification server is capable of handling some finite number of Push Notification subscriptions. This number will vary from server to server and is based on physical machine characteristics, network bandwidth, and operating system resource allocation. After a client establishes a connection to a DNS server, each record subscription is individually accepted or rejected. Servers may employ various techniques to limit subscriptions to a manageable level. Correspondingly, the client is free to establish simultaneous connections to alternate DNS servers that support DNS Push Notifications for the zone and distribute record subscriptions at its discretion. In this way, both clients and servers can react to resource constraints. Token bucket rate limiting schemes are also effective in providing fairness by a server across numerous client requests.</t>
<?rfc needLines="35" ?>
   </section>

   <section title="Protocol Operation">
     <t>A DNS Push Notification exchange begins with the client discovering the appropriate server, and then making a TLS/TCP connection to it. The client may then add and remove Push Notification subscriptions over this connection. In accordance with the current set of active subscriptions the server sends relevant asynchronous Push Notifications to the client. Note that a client MUST be prepared to receive (and silently ignore) Push Notifications for subscriptions it has previously removed, since there is no way to prevent the situation where a Push Notification is in flight from server to client while the client's UNSUBSCRIBE message cancelling that subscription is simultaneously in flight from client to server.</t>

     <t>The exchange between client and server terminates when either end closes the TCP connection with a TCP FIN or RST.</t>

     <t>A client SHOULD NOT make multiple TLS/TCP connections to the same DNS Push Notification server. A client SHOULD share a single TLS/TCP connection for all requests to the same DNS Push Notification server. This shared connection should be used for all DNS Queries and DNS Push Notification Queries queries to that server, and for DNS Update requests too when the <spanx style="verb">_dns&nbhy;update&nbhy;tls._tcp.&lt;zone&gt;</spanx> SRV record indicates that the same server also handles DNS Update requests. This is to reduce unnecessary load on the DNS Push Notification server.</t>

     <t>For the purposes here, the determination of "same server" is made by inspecting the target hostname and port, regardless of the name being queried, or what zone if falls within. A given server may support Push Notifications (and possibly DNS Updates too) for multiple DNS zones. When a client discovers that the DNS Push Notification server (and/or DNS Update server) for several different names (including names that fall within different zones) is the same target hostname and port, the client SHOULD use a single shared TCP connection for all relevant operations on those names. A client SHOULD NOT open multiple TCP connections to the same target host and port just because the names being queried (or updated) happen to fall within different zones.</t>

     <t>Note that the "same server" determination described here is made using the target hostname given in the SRV record, not the IP address(es) that the hostname resolves to. If two different target hostnames happen to resolve to the same IP address(es), then the client SHOULD NOT recognize these as the "same server" for the purposes of using a single shared connection to that server. If an administrator wishes to use a single server for multiple zones and/or multiple roles (e.g., both DNS Push Notifications and DNS Updates), and wishes to have clients use a single shared connection for operations on that server, then the administrator MUST use the same target hostname in the appropriate SRV records.</t>

     <t>However, server implementers and operators should be aware that this connection sharing may not be possible in all cases. A single client device may be home to multiple independent client software instances that don't know about each other, so a DNS Push Notification server MUST be prepared to accept multiple connections from the same client IP address. This is undesirable from an efficiency standpoint, but may be unavoidable in some situations, so a DNS Push Notification server MUST be prepared to accept multiple connections from the same client IP address.</t>

     <t>Clients SHOULD silently ignore unrecognized messages (both requests and responses) over the TLS/TCP connection. For example, UNSUBSCRIBE and RECONFIRM currently generate no response, but if future versions of this specification change that, existing clients SHOULD silently ignore these unexpected responses. This allows for backwards compatibility with future enhancements.</t>

      <section anchor="discovery" title="Discovery">
        <t>The first step in DNS Push Notification subscription is to discover an appropriate DNS server that supports DNS Push Notifications for the desired zone. The client MUST also determine which TCP port on the server is listening for connections, which need not be (and often is not) the typical TCP port 53 used for conventional DNS, or TCP port 853 used for <xref target="I-D.ietf-dprive-dns-over-tls">DNS over TLS</xref>.</t>
        <t>
          <list style="numbers">
            <t>The client begins the discovery by sending a DNS query to the local resolver with record type <xref target="RFC1035">SOA</xref> for the name of the record it wishes to subscribe.</t>

            <t>If the SOA record exists, it MUST be returned in the Answer Section of the response. If not, the local resolver SHOULD include the SOA record for the zone of the requested name in the Authority Section.</t>

            <t>If no SOA record is returned, the client then strips off the leading label from the requested name. If the resulting name has at least one label in it, the client sends a new SOA query and processing continues at step 2 above. If the resulting name is empty (the root label) then this is a network configuration error and the client gives up. The client MAY retry the operation at a later time.</t>

            <t>Once the SOA is known (either by virtue of being seen in the Answer Section, or in the Authority Section), the client sends a DNS query with type <xref target="RFC2782">SRV</xref> for the record name
            <spanx style="verb">_dns&nbhy;push&nbhy;tls._tcp.&lt;zone&gt;</spanx>, where &lt;zone&gt; is the owner name of the discovered SOA record.</t>

            <t>If the zone in question does not offer DNS Push Notifications then SRV record MUST NOT exist and the SRV query will return a negative answer.</t>

            <t>If the zone in question is set up to offer DNS Push Notifications then this SRV record MUST exist.
            The SRV <spanx style="verb">target</spanx> contains the name of the server providing DNS Push Notifications for the zone. The port number on which to contact the server is in the SRV record <spanx style="verb">port</spanx> field. The address(es) of the target host MAY be included in the Additional Section, however, the address records SHOULD be authenticated before use as described below in <xref target="tls_name_auth"/> <xref target="RFC7673"/>.</t>

            <t>More than one SRV record may be returned. In this case, the <spanx style="verb">priority</spanx> and <spanx style="verb">weight</spanx> values in the returned SRV records are used to determine the order in which to contact the servers for subscription requests. As described in <xref target="RFC2782">the SRV specification</xref>, the server with the lowest <spanx style="verb">priority</spanx> is first contacted. If more than one server has the same <spanx style="verb">priority</spanx>, the <spanx style="verb">weight</spanx> indicates the weighted probability that the client should contact that server. Higher weights have higher probabilities of being selected. If a server is not reachable or is not willing to accept a subscription request, then a subsequent server is to be contacted.</t>

          </list>
          Each time a client makes a new DNS Push Notification subscription connection, it SHOULD repeat the discovery process in order to determine the preferred DNS server for subscriptions at that time.
        </t>
<?rfc needLines="32" ?>
     </section>

     <section title="DNS Push Notification SUBSCRIBE">
       <t>A DNS Push Notification client indicates its desire to receive DNS Push Notifications for a given domain name by sending a SUBSCRIBE request over the established TCP connection to the server. A SUBSCRIBE request is formatted identically to a conventional <xref target="RFC1035">DNS QUERY request</xref>, except that the opcode is SUBSCRIBE (6) instead of QUERY (0). If neither QTYPE nor QCLASS are ANY (255) then this is a specific subscription to changes for the given name, type and class. If one or both of QTYPE or QCLASS are ANY (255) then this subscription matches any type and/or any class, as appropriate.</t>

       <t>NOTE: A little-known quirk of DNS is that in DNS QUERY requests, QTYPE and QCLASS 255 mean "ANY" not "ALL". They indicate that the server should respond with ANY matching records of its choosing, not necessarily ALL matching records. This can lead to some surprising and unexpected results, were a query returns some valid answers but not all of them, and makes QTYPE=ANY queries less useful than people sometimes imagine.</t>

       <t>When used in conjunction with DNS SUBSCRIBE, QTYPE and QCLASS 255 should be interpreted to mean "ALL", not "ANY". After accepting a subscription where one or both of QTYPE or QCLASS are 255, the server MUST send Push Notification Updates for ALL record changes that match the subscription, not just some of them.</t>

       <t>In a SUBSCRIBE request the DNS Header QR bit MUST be zero.<vspace />
       If the QR bit is not zero the message is not a SUBSCRIBE request.</t>

       <t>The AA, TC, RD, RA, Z, AD, and CD bits, and the RCODE field, MUST be zero on transmission, and MUST be silently ignored on reception.</t>

       <t>The ID field may be set to any value of the client's choosing, and the server MUST echo this value back in the response message. The client is not required to select unique ID values; it is permissible to use the same value (e.g., zero) for all operations. Since the name, qtype, and qclass are sufficient to uniquely identify a SUBSCRIBE operation on a connection, the name, qtype, and qclass in a SUBSCRIBE response are sufficient to correlate a response with its corresponding request. However, for convenience, the client may put any value it chooses in the ID field of the SUBSCRIBE request, and the server MUST echo that value back unchanged in the SUBSCRIBE response. Note that the ID field of Push Notification Update Messages is always zero, since a Push Notification Update Message could potentially match more than one subscription, or could relate to a subscription that the client has just cancelled with an UNSUBSCRIBE message.</t>

       <t>Like a DNS QUERY request, a SUBSCRIBE request MUST contain exactly one question. Since SUBSCRIBE requests are sent over TCP, multiple SUBSCRIBE requests can be concatenated in a single TCP stream and packed efficiently into TCP segments, so the ability to pack multiple SUBSCRIBE operations into a single DNS message within that TCP stream would add extra complexity for little benefit.</t>

       <t>ANCOUNT MUST be zero, and the Answer Section MUST be empty.<vspace />
       Any records in the Answer Section MUST be silently ignored.</t>

       <t>NSCOUNT MUST be zero, and the Authority Section MUST be empty.<vspace />
       Any records in the Authority Section MUST be silently ignored.</t>

       <t>ARCOUNT specifies the number of records in the Additional Data Section. Typically this is zero, but it may be nonzero in some cases, such as when the request includes an EDNS(0) OPT record.</t>

       <t>If accepted, the subscription will stay in effect until the client revokes the subscription or until the connection between the client and the server is closed.</t>

       <t>SUBSCRIBE requests on a given connection MUST be unique. A client MUST NOT send a SUBSCRIBE message that duplicates the name, type and class of an existing active subscription on that TLS/TCP connection. For the purpose of this matching, the established DNS case-insensitivity for US-ASCII letters applies (e.g., "foo.com" and "Foo.com" are the same). If a server receives such a duplicate SUBSCRIBE message this is an error and the server MUST immediately close the TCP connection.</t>

       <t>DNS wildcarding is not supported. That is, a wildcard ("*") in a SUBSCRIBE message matches only a literal wildcard character ("*") in the zone, and nothing else.</t>

       <t>Aliasing is not supported. That is, a CNAME in a SUBSCRIBE message matches only a literal CNAME record in the zone, and nothing else.</t>

       <t>A client may SUBSCRIBE to records that are unknown to the server at the time of the request (providing that the name falls within one of the zone(s) the server is responsible for) and this is not an error. The server MUST accept these requests and send Push Notifications if and when matches are found in the future.</t>

       <t>Since all SUBSCRIBE operations are implicitly long-lived operations, the server MUST interpret a SUBSCRIBE request as if it contained an EDNS(0) TCP Keepalive option <xref target="I-D.ietf-dnsop-edns-tcp-keepalive"/>. A client MUST NOT include an actual EDNS(0) TCP Keepalive option in the request, since it is automatic, and implied by the semantics of SUBSCRIBE. If a server receives a SUBSCRIBE request that does contain an actual EDNS(0) TCP Keepalive option this is an error and the server MUST immediately close the TCP connection.</t>

       <t>A SUBSCRIBE operation MAY include an explicit <xref target="RFC6891">EDNS(0)</xref> OPT record where necessary to carry additional EDNS(0) information other than a TCP Keepalive option.</t>

       <t>The presence of a SUBSCRIBE operation on a connection indicates to the server that the client fully implements
       <xref target="RFC6891">EDNS(0)</xref>, and can correctly understand any response that conforms to that specification. After receiving a SUBSCRIBE request, the server MAY include OPT record in any of its responses, as needed.</t>

<?rfc needLines="20" ?>
       <t>Each SUBSCRIBE request generates exactly one SUBSCRIBE response from the server.</t>

       <t>In a SUBSCRIBE response the DNS Header QR bit MUST be one.<vspace />
       If the QR bit is not one the message is not a SUBSCRIBE response.</t>

       <t>The AA, TC, RD, RA, Z, AD, and CD bits, MUST be zero on transmission, and MUST be silently ignored on reception.</t>

       <t>The ID field MUST echo the value given in the ID field of the SUBSCRIBE request.</t>

       <t>The Question Section MUST echo back the values provided by the client in the SUBSCRIBE request that generated this SUBSCRIBE response.</t>

       <t>ANCOUNT MUST be zero, and the Answer Section MUST be empty.<vspace />
       Any records in the Answer Section MUST be silently ignored.<vspace />
       If the subscription was accepted and there are positive answers for the requested name, type and class, then these positive answers MUST be communicated to the client in an immediately following Push Notification Update, not in the Answer Section of the SUBSCRIBE response.
       This simplifying requirement is made so that there is only a single way that information is communicated to a DNS Push Notification client. Since a DNS Push Notification client has to parse information received via Push Notification Updates anyway, it is simpler if it does not also have to parse information received via the Answer Section of a SUBSCRIBE response.</t>

       <t>NSCOUNT MUST be zero, and the Authority Section MUST be empty.<vspace />
       Any records in the Authority Section MUST be silently ignored.</t>

       <t>ARCOUNT specifies the number of records in the Additional Data Section, e.g., the EDNS(0) OPT record.</t>

<?rfc needLines="20" ?>
       <t>In the SUBSCRIBE response the RCODE indicates whether or not the subscription was accepted. Supported RCODEs are as follows:</t>
       <texttable title="SUBSCRIBE Response codes">
       <ttcol align="left">Mnemonic</ttcol>
       <ttcol align="center">Value</ttcol>
       <ttcol align="left">Description</ttcol>
       <c>NOERROR</c><c>0</c><c>SUBSCRIBE successful.</c>
       <c>FORMERR</c><c>1</c><c>Server failed to process request due to a malformed request.</c>
       <c>SERVFAIL</c><c>2</c><c>Server failed to process request due to resource exhaustion.</c>
       <c>NXDOMAIN</c><c>3</c><c>NOT APPLICABLE. DNS Push Notification MUST NOT return NXDOMAIN errors in response to SUBSCRIBE requests.</c>
       <c>NOTIMP</c><c>4</c><c>Server does not implement DNS Push Notifications.</c>
       <c>REFUSED</c><c>5</c><c>Server refuses to process request for policy or security reasons.</c>
       <c>NOTAUTH</c><c>9</c><c>Server is not authoritative for the requested name.</c>
       </texttable>

       <t>This document specifies only these RCODE values for SUBSCRIBE Responses. Servers sending SUBSCRIBE Responses SHOULD use one of these values. However, future circumstances may create situations where other RCODE values are appropriate in SUBSCRIBE Responses, so clients MUST be prepared to accept SUBSCRIBE Responses with any RCODE value.</t>

       <t>In the first SUBSCRIBE response on a connection, the server MUST include an explicit EDNS(0) TCP Keepalive option. If the first SUBSCRIBE response does not include an explicit EDNS(0) TCP Keepalive option this is an error and the client MUST immediately close the TCP connection. In this case the client should act as if the response contained an EDNS(0) TCP Keepalive option with a value of one hour, and not attempt any further DNS Push Notification requests to that server until one hour has passed. This situation may occur if a client connects to a server that doesn't implement DNS Push Notifications at all, and it is important not to burden such servers with continuous retries.</t>

       <t>The server MAY include EDNS(0) TCP Keepalive options in subsequent messages, if the idle timeout changes. If the client receives subsequent messages that do not contain an explicit EDNS(0) TCP Keepalive option then the idle timeout for that connection remains unchanged at that time.</t>

<?rfc needLines="20" ?>
       <t>In an error response, with nonzero RCODE, the server MUST contain an EDNS(0) TCP Keepalive option specifying the delay before the client submits further requests to this server:
         <list style="bullets">
           <t>For RCODE = 1 (FORMERR) the delay may be any value selected by the implementer. A value of one minute is RECOMMENDED, to avoid high load from defective clients.</t>

           <t>For RCODE = 2 (SERVFAIL), which occurs due to resource exhaustion, the delay should be chosen according to the level of server overload and the anticipated duration of that overload. By default, a value of one minute is RECOMMENDED.</t>

           <t>For RCODE = 4 (NOTIMP), which occurs on a server that doesn't implement DNS Push Notifications, it is unlikely that the server will begin supporting DNS Push Notifications in the next few minutes, so the retry delay SHOULD be one hour. Note that a server that doesn't implement DNS Push Notifications will most likely not implement this retry delay mechanism using the EDNS(0) TCP Keepalive option either, and in this case the client will fall back to the case described above specifying how to handle SUBSCRIBE responses that do not contain an EDNS(0) TCP Keepalive option.</t>

           <t>For RCODE = 5 (REFUSED), which occurs on a server that implements DNS Push Notifications, but is currently configured to disallow DNS Push Notifications, the retry delay may be any value selected by the implementer and/or configured by the operator.<vspace />
           This is a misconfiguration, since this server is listed in a <spanx style="verb">_dns&nbhy;push&nbhy;tls._tcp.&lt;zone&gt;</spanx> SRV record, but the server itself is not currently configured to support DNS Push Notifications. Since it is possible that the misconfiguration may be repaired at any time, the retry delay should not be set too high. By default, a value of 5 minutes is RECOMMENDED.</t>

           <t>For RCODE = 9 (NOTAUTH), which occurs on a server that implements DNS Push Notifications, but is not configured to be authoritative for the requested name, the retry delay may be any value selected by the implementer and/or configured by the operator.
           <vspace />This is a misconfiguration, since this server is listed in a <spanx style="verb">_dns&nbhy;push&nbhy;tls._tcp.&lt;zone&gt;</spanx> SRV record, but the server itself is not currently configured to support DNS Push Notifications for that zone. Since it is possible that the misconfiguration may be repaired at any time, the retry delay should not be set too high. By default, a value of 5 minutes is RECOMMENDED.</t>

           <t>For other RCODE values, the retry delay should be set by the server as appropriate for that error condition. By default, a value of 5 minutes is RECOMMENDED.</t>
         </list>
       </t>

       <t>For RCODE = 9 (NOTAUTH), the time delay applies to requests for other names falling within the same zone. Requests for names falling within other zones are not subject to the delay. For all other RCODEs the time delay applies to all subsequent requests to this server.</t>

       <t>After sending an error response the server MAY close the TCP connection with a FIN, or MAY allow it to remain open, depending on the nature of the error. Clients MUST correctly handle both cases.</t>

<?rfc needLines="20" ?>
     </section>

     <section title="DNS Push Notification UNSUBSCRIBE">
       <t>To cancel an individual subscription without closing the entire connection, the client sends an UNSUBSCRIBE message over the established TCP connection to the server. The UNSUBSCRIBE message is formatted identically to the SUBSCRIBE message which created the subscription, with the exact same name, type and class, except that the opcode is UNSUBSCRIBE (7) instead of SUBSCRIBE (6).</t>

       <t>A client MUST NOT send an UNSUBSCRIBE message that does not exactly match the name, type and class of an existing active subscription on that TLS/TCP connection. If a server receives such an UNSUBSCRIBE message this is an error and the server MUST immediately close the connection.</t>

       <t>No response message is generated as a result of processing an UNSUBSCRIBE message.</t>

       <t>Having being successfully revoked with a correctly-formatted UNSUBSCRIBE message, the previously referenced subscription is no longer active and the server MAY discard the state associated with it immediately, or later, at the server's discretion.</t>
<?rfc needLines="30" ?>
     </section>

     <section title="DNS Push Notification Update Messages">
       <t>Once a subscription has been successfully established, the server generates Push Notification Updates to send to the client as appropriate. An initial Push Notification Update will be sent immediately in the case that the answer set was non-empty at the moment the subscription was established. Subsequent changes to the answer set are then communicated to the client in subsequent Push Notification Updates.</t>

       <t>The format of Push Notification Updates borrows from the existing <xref target="RFC2136">DNS Update</xref> protocol, with some simplifications.</t>

<?rfc needLines="28" ?>

       <t>The following figure shows the existing DNS Update header format:
       <figure align="center" anchor="packet_header1"><artwork align="center"><![CDATA[
                                1  1  1  1  1  1
  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                      ID                       |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|QR|   Opcode  |          Z         |   RCODE   |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                    ZOCOUNT                    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                    PRCOUNT                    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                    UPCOUNT                    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                    ADCOUNT                    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
               ]]></artwork>
       </figure>
       </t>

       <t>For DNS Push Notifications the following rules apply:</t>

       <t>The QR bit MUST be zero, and the Opcode MUST be UPDATE (5).<vspace />
       Messages received where this is not true are not Push Notification Update Messages and should be silently ignored for the purposes of Push Notification Update Message handling.</t>

       <t>ID, the Z bits, and RCODE MUST be zero on transmission,<vspace />
       and MUST be silently ignored on reception.</t>

       <t>ZOCOUNT MUST be zero, and the Zone Section MUST be empty.<vspace />
       Any records in the Zone Section MUST be silently ignored.</t>

       <t>PRCOUNT MUST be zero, and the Prerequisite Section MUST be empty.<vspace />
       Any records in the Prerequisite Section MUST be silently ignored.</t>

       <t>UPCOUNT specifies the number of records in the Update Section.</t>

       <t>ADCOUNT specifies the number of records in the Additional Data Section. Typically this is zero, but it may be nonzero in some cases, such as when the message includes an EDNS(0) OPT record.</t>

<?rfc needLines="15" ?>
       <t>The Update Section contains the relevant change information for the client,
       formatted identically to a <xref target="RFC2136">DNS Update</xref>. To recap:
         <list style="bullets">
           <t>Delete all RRsets from a name:<vspace />
           TTL=0, CLASS=ANY, RDLENGTH=0, TYPE=ANY.</t>
           <t>Delete an RRset from a name:<vspace />
           TTL=0, CLASS=ANY, RDLENGTH=0;<vspace />
           TYPE specifies the RRset being deleted.</t>
           <t>Delete an individual RR from a name:<vspace />
           TTL=0, CLASS=NONE;<vspace />
           TYPE, RDLENGTH and RDATA specifies the RR being deleted.</t>
           <t>Add to an RRset:<vspace />
           TTL, CLASS, TYPE, RDLENGTH and RDATA specifies the RR being added.</t>
         </list>
       </t>

       <t>When processing the records received in a Push Notification Update Message, the receiving client MUST validate that the records being added or deleted correspond with at least one currently active subscription on that connection. Specifically, the record name MUST match the name given in the SUBSCRIBE request, subject to the usual established DNS case-insensitivity for US-ASCII letters.
       If the QTYPE in the SUBSCRIBE request was not ANY (255) then the TYPE of the record must match the QTYPE given in the SUBSCRIBE request.
       If the QCLASS in the SUBSCRIBE request was not ANY (255) then the CLASS of the record must match the QCLASS given in the SUBSCRIBE request.
       If a matching active subscription on that connection is not found, then that individual record addition/deletion is silently ignored. Processing of other additions and deletions in this message is not affected. The TCP connection is not closed. This is to allow for the race condition where a client sends an outbound UNSUBSCRIBE while inbound Push Notification Updates for that subscription from the server are still in flight.</t>

       <t>In the case where a single change affects more than one active subscription, only one update is sent. For example, an update adding a given record may match both a SUBSCRIBE request with the same QTYPE and a different SUBSCRIBE request with QTYPE=ANY. It is not the case that two updates are sent because the new record matches two active subscriptions.</t>

       <t>The server SHOULD encode change notifications in the most efficient manner possible. For example, when three AAAA records are deleted from a given name, and no other AAAA records exist for that name, the server SHOULD send a "delete an RRset from a name" update, not three separate "delete an individual RR from a name" updates. Similarly, when both an SRV and a TXT record are deleted from a given name, and no other records of any kind exist for that name, the server SHOULD send a "delete all RRsets from a name" update, not two separate "delete an RRset from a name" updates.</t>

       <t>A server SHOULD combine multiple change notifications in a single Update Message when possible, even if those change notifications apply to different subscriptions. Conceptually, a Push Notification Update Message is a connection-level concept, not a subscription-level concept.</t>

       <t>Push Notification Update Messages MAY contain an EDNS(0) TCP Keepalive option
       <xref target="I-D.ietf-dnsop-edns-tcp-keepalive"/>
       if the idle timeout has changed since the last time the server sent an EDNS(0) TCP Keepalive option on this connection.</t>

       <t>In the event that the server wishes to inform a client of a new idle timeout for the connection, the server MAY combine that with the next message it sends to the client, or the server MAY send an empty Push Notification Update Message (zero records in the Update Section) to carry the EDNS(0) TCP Keepalive option. Clients MUST correctly receive and process the EDNS(0) TCP Keepalive option in both cases.</t>

       <t>Reception of a Push Notification Update Message does not directly generate a response back to the server. (Updates may indirectly generate other operations; e.g., a Push Notification Update Message declaring the appearance of a PTR record could lead to a query for the SRV record named in the rdata of that PTR record<xref target="RFC6763"/>.</t>

       <t>The TTL of an added record is stored by the client and decremented as time passes, with the caveat that for as long as a relevant subscription is active, the TTL does not decrement below 1 second. For as long as a relevant subscription remains active, the client SHOULD assume that when a record goes away the server will notify it of that fact. Consequently, a client does not have to poll to verify that the record is still there. Once a subscription is cancelled (individually, or as a result of the TCP connection being closed) record aging resumes and records are removed from the local cache when their TTL reaches zero.</t>
<?rfc needLines="30" ?>
     </section>

     <section title="DNS RECONFIRM">
       <t>Sometimes, particularly when used with a <xref target="I-D.ietf-dnssd-hybrid">Hybrid Proxy</xref>, a DNS Zone may contain stale data. When a client encounters data that it believe may be stale (e.g., an SRV record referencing a target host+port that is not responding to connection requests) the client sends a DNS RECONFIRM message to request that the server re-verify that the data is still valid. For a Hybrid Proxy, this causes it to issue new Multicast DNS requests to ascertain whether the target device is still present. For other kinds of DNS server the RECONFIRM operation is currently undefined and SHOULD be silently ignored.</t>

       <t>A RECONFIRM request is formatted similarly to a conventional <xref target="RFC1035">DNS QUERY request</xref>, except that the opcode is RECONFIRM (8) instead of QUERY (0). QTYPE MUST NOT be the value ANY (255). QCLASS MUST NOT be the value ANY (255).</t>

       <t>In a RECONFIRM request the DNS Header QR bit MUST be zero.<vspace />
       If the QR bit is not zero the message is not a RECONFIRM request.</t>

       <t>The AA, TC, RD, RA, Z, AD, and CD bits, the ID field, and the RCODE field, MUST be zero on transmission, and MUST be silently ignored on reception.</t>

       <t>Like a DNS QUERY request, a RECONFIRM request MUST contain exactly one question. Since RECONFIRM requests are sent over TCP, multiple RECONFIRM requests can be concatenated in a single TCP stream and packed efficiently into TCP segments, so the ability to pack multiple RECONFIRM operations into a single DNS message within that TCP stream would add extra complexity for little benefit.</t>

       <t>ANCOUNT MUST be nonzero, and the Answer Section MUST contain the rdata for the record(s) that the client believes to be in doubt.</t>

       <t>NSCOUNT MUST be zero, and the Authority Section MUST be empty.<vspace />
       Any records in the Authority Section MUST be silently ignored.</t>

       <t>ARCOUNT specifies the number of records in the Additional Data Section. Typically this is zero, but it may be nonzero in some cases, such as when the request includes an EDNS(0) OPT record.</t>

       <t>DNS wildcarding is not supported. That is, a wildcard ("*") in a SUBSCRIBE message matches only a wildcard ("*") in the zone, and nothing else.</t>

       <t>Aliasing is not supported. That is, a CNAME in a SUBSCRIBE message matches only a CNAME in the zone, and nothing else.</t>

       <t>No response message is generated as a result of processing a RECONFIRM message.</t>

       <t>If the server receiving the RECONFIRM request determines that the records are in fact no longer valid, then subsequent DNS Push Notification Update Messages will be generated to inform interested clients. Thus, one client discovering that a previously-advertised printer is no longer present has the side effect of informing all other interested clients that the printer in question is now gone.</t>
     </section>

     <section anchor="termination" title="DNS Push Notification Termination Message">
       <t>If a server is low on resources it MAY simply terminate a client connection with a TCP RST. However, the likely behaviour of the client may be simply to reconnect immediately, putting more burden on the server. Therefore, a server SHOULD instead choose to shed client load by (a) sending a DNS Push Notification Termination Message and then (b) immediately closing the client connection with a TCP FIN instead of RST, thereby facilitating reliable delivery of the Termination Message. Upon successful reception of the Termination Message the client is expected to close the connection. The server SHOULD set a timer and, if the client has not closed the connection within a reasonable time, the server SHOULD then terminate the TCP connection with a TCP RST. The RECOMMENDED time the server should wait before terminating the TCP connection with a TCP RST is ten seconds.</t>

       <t>The format of a Termination Message is similar to a Push Notification Update.</t>

<?rfc needLines="28" ?>

       <t>The following figure shows the existing DNS Update header format:
       <figure align="center" anchor="packet_header2"><artwork align="center"><![CDATA[
                                1  1  1  1  1  1
  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                      ID                       |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|QR|   Opcode  |          Z         |   RCODE   |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                    ZOCOUNT                    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                    PRCOUNT                    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                    UPCOUNT                    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                    ADCOUNT                    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
               ]]></artwork>
       </figure>
       </t>

       <t>For Termination Messages the following rules apply:</t>

       <t>The QR bit MUST be zero, and the Opcode MUST be UPDATE (5).<vspace />
       Messages received where this is not true are not Termination Messages and should be silently ignored.</t>

       <t>ID and the Z bits MUST be zero on transmission,<vspace />
       and MUST be silently ignored on reception.</t>

       <t>ZOCOUNT MUST be zero, and the Zone Section MUST be empty.<vspace />
       Any records in the Zone Section MUST be silently ignored.</t>

       <t>PRCOUNT MUST be zero, and the Prerequisite Section MUST be empty.<vspace />
       Any records in the Prerequisite Section MUST be silently ignored.</t>

       <t>UPCOUNT MUST be zero, and the Update Section MUST be empty.<vspace />
       Any records in the Update Section MUST be silently ignored.</t>

       <t>ADCOUNT specifies the number of records in the Additional Data Section, e.g., the EDNS(0) OPT record..</t>

       <t>The RCODE MUST contain a nonzero code giving the reason for termination, as indicated below:</t>
       <texttable title="Termination Response codes">
       <ttcol align="left">Mnemonic</ttcol>
       <ttcol align="center">Value</ttcol>
       <ttcol align="left">Description</ttcol>
       <c>SERVFAIL</c><c>2</c><c>The server is overloaded due to resource exhaustion.</c>
       <c>REFUSED</c><c>5</c><c>The server has been reconfigured and is no longer accepting DNS Push Notification requests for one or more of the currently subscribed names.</c>
       </texttable>

       <t>This document specifies only these two RCODE values for Termination Messages. Servers sending Termination Messages SHOULD use one of these two values. However, future circumstances may create situations where other RCODE values are appropriate in Termination Messages, so clients MUST be prepared to accept Termination Messages with any RCODE value. In particular, a Termination Message with RCODE value zero (NOERROR) is still a Termination Message and should be treated as such.</t>

       <t>The Termination Message MUST contain an EDNS(0) TCP Keepalive option <xref target="I-D.ietf-dnsop-edns-tcp-keepalive"/>. The client MUST wait for the time indicated in the EDNS(0) TCP Keepalive option's idle timeout before attempting any new connections to this server. A client that receives a Termination Message without an EDNS(0) TCP Keepalive option SHOULD treat it as equivalent to a TCP Keepalive option with a zero timeout value.</t>

       <t>In the case where the server is rejecting some, but not all, of the existing subscriptions (perhaps because it has been reconfigured and is no longer authoritative for those names) with a REFUSED (5) RCODE, the EDNS(0) TCP Keepalive option's idle timeout MAY be zero, indicating that the client SHOULD attempt to re-establish its subscriptions immediately.</t>

       <t>In the case where a server is terminating a large number of connections at once (e.g., if the system is restarting) and the server doesn't want to be inundated with a flood of simultaneous retries, it SHOULD send different EDNS(0) TCP Keepalive values to each client. These adjustments MAY be selected randomly, pseudorandomly, or deterministically (e.g., incrementing the time value by one tenth of a second for each successive client, yielding a post-restart reconnection rate of ten clients per second).</t>

<?rfc needLines="15" ?>
     </section>
   </section>

   <section anchor="Security" title="Security Considerations">
     <t>TLS support is REQUIRED in DNS Push Notifications. There is no provision for opportunistic encryption using a mechanism like <spanx style="verb">STARTTLS</spanx>.</t>

     <t>DNSSEC is RECOMMENDED for DNS Push Notifications. TLS alone does not provide complete security. TLS certificate verification can provide reasonable assurance that the client is really talking to the server associated with the desired host name, but since the desired host name is learned via a DNS SRV query, if the SRV query is subverted then the client may have a secure connection to a rogue server. DNSSEC can provided added confidence that the SRV query has not been subverted.</t>

     <section title="Security Services">
       <t>It is the goal of using TLS to provide the following security services:
         <list style="hanging">
           <t hangText="Confidentiality:">All application-layer communication is encrypted with the goal that no party should be able to decrypt it except the intended receiver.</t>
           <t hangText="Data integrity protection:">Any changes made to the communication in transit are detectable by the receiver.</t>
           <t hangText="Authentication:">An end-point of the TLS communication is authenticated as the intended entity to communicate with.</t>
         </list>
       </t>
       <t>Deployment recommendations on the appropriate key lengths and cypher suites are beyond the scope of this document. Please refer to <xref target="RFC7525">TLS Recommendations</xref> for the best current practices. Keep in mind that best practices only exist for a snapshot in time and recommendations will continue to change. Updated versions or errata may exist for these recommendations.</t>
     </section>

     <section anchor="tls_name_auth" title="TLS Name Authentication">
       <t>As described in <xref target="discovery"/>, the client discovers the DNS Push Notification server using an SRV lookup for the record name <spanx style="verb">_dns&nbhy;push&nbhy;tls._tcp.&lt;zone&gt;</spanx>. The server connection endpoint SHOULD then be authenticated using DANE TLSA records for the associated SRV record. This associates the target's name and port number with a trusted TLS certificate <xref target="RFC7673"/>. This procedure uses the TLS Sever Name Indication (SNI) extension <xref target="RFC6066"/> to inform the server of the name the client has authenticated through the use of TLSA records. Therefore, if the SRV record passes DNSSEC validation and a TLSA record matching the target name is useable, an SNI extension MUST be used for the target name to ensure the client is connecting to the server it has authenticated. If the target name does not have a usable TLSA record, then the use of the SNI extension is optional.</t>
     </section>

     <section title="TLS Compression">
       <t>In order to reduce the chances of compression related attacks, TLS-level compression SHOULD be disabled when using TLS versions 1.2 and earlier. In the draft version of <xref target="I-D.ietf-tls-tls13">TLS 1.3</xref>, TLS-level compression has been removed completely.</t>
     </section>

     <section title="TLS Session Resumption">
       <t>TLS Session Resumption is permissible on DNS Push Notification servers. The server may keep TLS state with Session IDs <xref target="RFC5246"/> or operate in stateless mode by sending a Session Ticket <xref target="RFC5077"/> to the client for it to store. However, once the connection is closed, any existing subscriptions will be dropped. When the TLS session is resumed, the DNS Push Notification server will not have any subscription state and will proceed as with any other new connection. Use of TLS Session Resumption allows a new TLS connection to be set up more quickly, but the client will still have to recreate any desired subscriptions.</t>
<?rfc needLines="9" ?>
     </section>
   </section>

   <section anchor="IANA" title="IANA Considerations">
     <t>This document defines the service name: <spanx style="verb">_dns&nbhy;push&nbhy;tls._tcp</spanx>.<vspace />
     It is only applicable for the TCP protocol.<vspace />
     This name is to be published in the IANA Service Name Registry.</t>
     <t>This document defines three DNS OpCodes: SUBSCRIBE with (tentative) value 6, UNSUBSCRIBE with (tentative) value 7, and RECONFIRM with (tentative) value 8.</t>
   </section>

   <section anchor="Acknowledgements" title="Acknowledgements">
     <t>The authors would like to thank Kiren Sekar and Marc Krochmal for previous work completed in this field.</t>

     <t>This draft has been improved due to comments from Ran Atkinson, Tim Chown, Mark Delany, Ralph Droms, Bernie Volz, Jan Komissar, Manju Shankar Rao, Markus Stenberg, Dave Thaler, and Soraia Zlatkovic.</t>
<?rfc needLines="15" ?>
   </section>
 </middle>

 <!--  *****BACK MATTER ***** -->

 <back>
   <!-- References split into informative and normative -->

   <!-- There are 2 ways to insert reference entries from the citation libraries:
    1. define an ENTITY at the top, and use "ampersand character"RFC2629; here (as shown)
    2. simply use a PI "less than character"?rfc include="reference.RFC.2119.xml"?> here
       (for I-Ds: include="reference.I-D.narten-iana-considerations-rfc2434bis.xml")

    Both are cited textually in the same manner: by using xref elements.
    If you use the PI option, xml2rfc will, by default, try to find included files in the same
    directory as the including file. You can also define the XML_LIBRARY environment variable
    with a value containing a set of directories to search.  These can be either in the local
    filing system or remote ones accessed by http (http://domain/dir/... ).-->

   <references title="Normative References">
     &I-D.ietf-tls-tls13;
     &RFC0768;
     &RFC0793;
     &RFC1034;
     &RFC1035;
     &RFC1123;
     &RFC2119;
     &RFC2136;
     &RFC2782;
     &RFC5246;
     &RFC6066;
     &RFC6891;
     &RFC6895;
     &RFC7673;
     &RFC7766;
     &I-D.ietf-dnsop-edns-tcp-keepalive;
   </references>

<!-- Use needLines to make sure "Authors' Addresses" line doesn't appear as the last line on the page -->
<?rfc needLines="9" ?>

   <references title="Informative References">

     &I-D.sekar-dns-llq;

<reference anchor='I-D.ietf-dnssd-hybrid'>
<front>
<title>Hybrid Unicast/Multicast DNS-Based Service Discovery</title>

<author initials='S' surname='Cheshire' fullname='Stuart Cheshire'>
    <organization />
</author>

<date day='5' month='November' year='2015'/>

<abstract><t>Performing DNS-Based Service Discovery using purely link-local Multicast DNS enables discovery of services that are on the local link, but not (without some kind of proxy or similar special support) of services that are outside the local link.  Using a very large local link with thousands of hosts improves service discovery, but at the cost of large amounts of multicast traffic.  Performing DNS-Based Service Discovery using purely Unicast DNS is more efficient, but requires configuration of DNS Update keys on the devices offering the services, which can be onerous for simple devices like printers and network cameras.  Hence a compromise is needed, that provides easy service discovery without requiring either large amounts of multicast traffic or onerous configuration.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-dnssd-hybrid-03' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-dnssd-hybrid-03.txt' />
</reference>


     &RFC1996;
     &RFC4287;
     &RFC4953;
     &RFC5077;
     &RFC6762;
     &RFC6763;
     &RFC7525;

     <reference anchor="XEP0060">
       <front>
         <title>Publish-Subscribe</title>
         <author initials="P." surname="Millard" fullname="Peter Millard">
           <organization/>
           <address>
             <email/>
           </address>
         </author>
         <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
           <organization/>
           <address>
             <email>peter@andyet.net</email>
           </address>
         </author>
         <author initials="R." surname="Meijer" fullname="Ralph Meijer">
           <organization/>
           <address>
             <email>ralphm@ik.nu</email>
           </address>
         </author>
         <date day="01" month="July" year="2010"/>
       </front>
       <seriesInfo name="XSF XEP" value="0060"/>
       <format type="HTML" target="http://xmpp.org/extensions/xep-0060.html"/>
     </reference>

     <reference anchor='IPJ.9-4-TCPSYN'>
       <front>
         <title>Defenses Against TCP SYN Flooding Attacks</title>
         <author initials='W.' surname='Eddy' fullname='Wesley Eddy'>
           <organization>Verizon Federal Network Systems</organization>
           <address>
             <email>weddy@grc.nasa.gov</email>
           </address>
         </author>
         <date year='2006' month='December' />
         <keyword>TCP</keyword>
       </front>
       <seriesInfo name="The Internet Protocol Journal," value='Cisco Systems' />
       <seriesInfo name='Volume' value='9' />
       <seriesInfo name='Number' value='4' />
       <format type='PDF' octets='882020' target="http://www.cisco.com/web/about/ac123/ac147/archived_issues/ipj_9-4/ipj_9-4.pdf" />
       <format type='HTML' octets='65566' target="http://www.cisco.com/web/about/ac123/ac147/archived_issues/ipj_9-4/syn_flooding_attacks.html" />
     </reference>

     &I-D.ietf-dprive-dns-over-tls;
   </references>
 </back>
</rfc>
