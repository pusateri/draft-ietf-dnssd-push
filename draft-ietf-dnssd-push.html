<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>DNS Push Notifications</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
      /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
      a.info {
          /* This is the key. */
          position: relative;
          z-index: 24;
          text-decoration: none;
      }
      a.info:hover {
          z-index: 25;
          color: #FFF; background-color: #900;
      }
      a.info span { display: none; }
      a.info:hover span.info {
          /* The span will display just on :hover state. */
          display: block;
          position: absolute;
          font-size: smaller;
          top: 2em; left: -5em; width: 15em;
          padding: 2px; border: 1px solid #333;
          color: #900; background-color: #EEE;
          text-align: left;
      }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Requirements Language"/>
<link href="#rfc.section.2" rel="Chapter" title="2 Motivation"/>
<link href="#rfc.section.3" rel="Chapter" title="3 Overview"/>
<link href="#rfc.section.4" rel="Chapter" title="4 Transport"/>
<link href="#rfc.section.5" rel="Chapter" title="5 State Considerations"/>
<link href="#rfc.section.6" rel="Chapter" title="6 Protocol Operation"/>
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Discovery"/>
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 DNS Push Notification SUBSCRIBE"/>
<link href="#rfc.section.6.2.1" rel="Chapter" title="6.2.1 SUBSCRIBE Request"/>
<link href="#rfc.section.6.2.2" rel="Chapter" title="6.2.2 SUBSCRIBE Response"/>
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 DNS Push Notification Updates"/>
<link href="#rfc.section.6.3.1" rel="Chapter" title="6.3.1 PUSH Message"/>
<link href="#rfc.section.6.3.2" rel="Chapter" title="6.3.2 PUSH Response"/>
<link href="#rfc.section.6.4" rel="Chapter" title="6.4 DNS Push Notification UNSUBSCRIBE"/>
<link href="#rfc.section.6.4.1" rel="Chapter" title="6.4.1 UNSUBSCRIBE Request"/>
<link href="#rfc.section.6.4.2" rel="Chapter" title="6.4.2 UNSUBSCRIBE Response"/>
<link href="#rfc.section.6.5" rel="Chapter" title="6.5 DNS Push Notification RECONFIRM"/>
<link href="#rfc.section.6.5.1" rel="Chapter" title="6.5.1 RECONFIRM Request"/>
<link href="#rfc.section.6.5.2" rel="Chapter" title="6.5.2 RECONFIRM Response"/>
<link href="#rfc.section.6.6" rel="Chapter" title="6.6 Client-Initiated Termination"/>
<link href="#rfc.section.7" rel="Chapter" title="7 Security Considerations"/>
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Security Services"/>
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 TLS Name Authentication"/>
<link href="#rfc.section.7.3" rel="Chapter" title="7.3 TLS Compression"/>
<link href="#rfc.section.7.4" rel="Chapter" title="7.4 TLS Session Resumption"/>
<link href="#rfc.section.8" rel="Chapter" title="8 IANA Considerations"/>
<link href="#rfc.section.9" rel="Chapter" title="9 Acknowledgements"/>
<link href="#rfc.references" rel="Chapter" title="10 References"/>
<link href="#rfc.references.1" rel="Chapter" title="10.1 Normative References"/>
<link href="#rfc.references.2" rel="Chapter" title="10.2 Informative References"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.5.2 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Pusateri, T. and S. Cheshire" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-dnssd-push-11" />
  <meta name="dct.issued" scheme="ISO8601" content="2017-5-11" />
  <meta name="dct.abstract" content="The Domain Name System (DNS) was designed to return matching records efficiently for queries for data that is relatively static.  When those records change frequently, DNS is still efficient at returning the updated results when polled. But there exists no mechanism" />
  <meta name="description" content="The Domain Name System (DNS) was designed to return matching records efficiently for queries for data that is relatively static.  When those records change frequently, DNS is still efficient at returning the updated results when polled. But there exists no mechanism" />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">Internet Engineering Task Force</td>
  <td class="right">T. Pusateri</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">Seeking affiliation</td>
</tr>
<tr>
  <td class="left">Intended status: Standards Track</td>
  <td class="right">S. Cheshire</td>
</tr>
<tr>
  <td class="left">Expires: November 12, 2017</td>
  <td class="right">Apple Inc.</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">May 11, 2017</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">DNS Push Notifications<br />
  <span class="filename">draft-ietf-dnssd-push-11</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>The Domain Name System (DNS) was designed to return matching records efficiently for queries for data that is relatively static.  When those records change frequently, DNS is still efficient at returning the updated results when polled. But there exists no mechanism<br/> for a client to be asynchronously notified when these changes occur.<br/> This document defines a mechanism for a client to be notified<br/> of such changes to DNS records, called DNS Push Notifications.</p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on November 12, 2017.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2017 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Requirements Language</a></li>
</ul><li>2.   <a href="#rfc.section.2">Motivation</a></li>
<li>3.   <a href="#rfc.section.3">Overview</a></li>
<li>4.   <a href="#rfc.section.4">Transport</a></li>
<li>5.   <a href="#rfc.section.5">State Considerations</a></li>
<li>6.   <a href="#rfc.section.6">Protocol Operation</a></li>
<ul><li>6.1.   <a href="#rfc.section.6.1">Discovery</a></li>
<li>6.2.   <a href="#rfc.section.6.2">DNS Push Notification SUBSCRIBE</a></li>
<ul><li>6.2.1.   <a href="#rfc.section.6.2.1">SUBSCRIBE Request</a></li>
<li>6.2.2.   <a href="#rfc.section.6.2.2">SUBSCRIBE Response</a></li>
</ul><li>6.3.   <a href="#rfc.section.6.3">DNS Push Notification Updates</a></li>
<ul><li>6.3.1.   <a href="#rfc.section.6.3.1">PUSH Message</a></li>
<li>6.3.2.   <a href="#rfc.section.6.3.2">PUSH Response</a></li>
</ul><li>6.4.   <a href="#rfc.section.6.4">DNS Push Notification UNSUBSCRIBE</a></li>
<ul><li>6.4.1.   <a href="#rfc.section.6.4.1">UNSUBSCRIBE Request</a></li>
<li>6.4.2.   <a href="#rfc.section.6.4.2">UNSUBSCRIBE Response</a></li>
</ul><li>6.5.   <a href="#rfc.section.6.5">DNS Push Notification RECONFIRM</a></li>
<ul><li>6.5.1.   <a href="#rfc.section.6.5.1">RECONFIRM Request</a></li>
<li>6.5.2.   <a href="#rfc.section.6.5.2">RECONFIRM Response</a></li>
</ul><li>6.6.   <a href="#rfc.section.6.6">Client-Initiated Termination</a></li>
</ul><li>7.   <a href="#rfc.section.7">Security Considerations</a></li>
<ul><li>7.1.   <a href="#rfc.section.7.1">Security Services</a></li>
<li>7.2.   <a href="#rfc.section.7.2">TLS Name Authentication</a></li>
<li>7.3.   <a href="#rfc.section.7.3">TLS Compression</a></li>
<li>7.4.   <a href="#rfc.section.7.4">TLS Session Resumption</a></li>
</ul><li>8.   <a href="#rfc.section.8">IANA Considerations</a></li>
<li>9.   <a href="#rfc.section.9">Acknowledgements</a></li>
<li>10.   <a href="#rfc.references">References</a></li>
<ul><li>10.1.   <a href="#rfc.references.1">Normative References</a></li>
<li>10.2.   <a href="#rfc.references.2">Informative References</a></li>
</ul><li><a href="#rfc.authors">Authors' Addresses</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> Introduction</h1>
<p id="rfc.section.1.p.1">DNS records may be updated using <a href="#RFC2136">DNS Update</a> <cite title="NONE">[RFC2136]</cite>.  Other mechanisms such as a <a href="#DisProx">Discovery Proxy</a> <cite title="NONE">[DisProx]</cite> can also generate changes to a DNS zone.  This document specifies a protocol for DNS clients to subscribe to receive asynchronous notifications of changes to RRSets of interest. It is immediately relevant in the case of <a href="#RFC6763">DNS Service Discovery</a> <cite title="NONE">[RFC6763]</cite> but is not limited to that use case, and provides a general DNS mechanism for DNS record change notifications. Familiarity with the DNS protocol and DNS packet formats is assumed <a href="#RFC1034">[RFC1034]</a> <a href="#RFC1035">[RFC1035]</a> <a href="#RFC6895">[RFC6895]</a>.</p>
<h1 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1.</a> Requirements Language</h1>
<p id="rfc.section.1.1.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119">"Key words for use in RFCs to Indicate Requirement Levels"</a> <cite title="NONE">[RFC2119]</cite>.</p>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> Motivation</h1>
<p id="rfc.section.2.p.1">As the domain name system continues to adapt to new uses and changes in deployment, polling has the potential to burden DNS servers at many levels throughout the network. Other network protocols have successfully deployed a publish/subscribe model to state changes following the <a href="#obs">Observer design pattern</a> <cite title="NONE">[obs]</cite>.  <a href="#XEP0060">XMPP Publish-Subscribe</a> <cite title="NONE">[XEP0060]</cite> and <a href="#RFC4287">Atom</a> <cite title="NONE">[RFC4287]</cite> are examples. While DNS servers are generally highly tuned and capable of a high rate of query/response traffic, adding a publish/subscribe model for tracking changes to DNS records can result in more timely notification of changes with reduced CPU usage and lower network traffic.</p>
<p><a href="#RFC6762">Multicast DNS</a> <cite title="NONE">[RFC6762]</cite> implementations always listen on a well known link-local IP multicast group, and new services and updates are sent for all group members to receive. Therefore, Multicast DNS already has asynchronous change notification capability. However, when <a href="#RFC6763">DNS Service Discovery</a> <cite title="NONE">[RFC6763]</cite> is used across a wide area network using Unicast DNS (possibly facilitated via a <a href="#DisProx">Discovery Proxy</a> <cite title="NONE">[DisProx]</cite>) it would be beneficial to have an equivalent capability for Unicast DNS, to allow clients to learn about DNS record changes in a timely manner without polling.</p>
<p id="rfc.section.2.p.3">The <a href="#I-D.sekar-dns-llq">DNS Long-Lived Queries (LLQ)</a> <cite title="NONE">[I-D.sekar-dns-llq]</cite> mechanism is an existing deployed solution to provide asynchronous change notifications, used by Apple's <a href="#RFC6281">Back to My Mac Service</a> <cite title="NONE">[RFC6281]</cite>.  Back to My Mac was designed in an era when the data centre operations staff asserted that it was impossible for a server to handle large numbers of mostly-idle TCP connections, so LLQ had to defined as a UDP-based protocol, effectively replicating much of TCP's connection state management logic in user space, and creating its own poor imitations of existing TCP features like the three-way handshake, flow control, and reliability.</p>
<p id="rfc.section.2.p.4">This document builds on experience gained with the LLQ protocol, with an improved design.  Instead of using UDP, this specification uses TCP, and therefore doesn't need to reinvent existing TCP functionality.  Using TCP also gives long-lived low-traffic connections better longevity through NAT gateways without resorting to excessive keepalive traffic.  Instead of inventing a new vocabulary of messages to communicate DNS zone changes as LLQ did, this specification adopts the syntax and semantics of <a href="#RFC2136">DNS Update messages</a> <cite title="NONE">[RFC2136]</cite>.</p>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> Overview</h1>
<p id="rfc.section.3.p.1">The existing <a href="#RFC2136">DNS Update protocol</a> <cite title="NONE">[RFC2136]</cite> provides a mechanism for clients to add or delete individual resource records (RRs) or entire resource record sets (RRSets) on the zone's server.</p>
<p id="rfc.section.3.p.2">This specification adopts a simplified subset of these existing syntax and semantics, and uses them for DNS Push Notification messages going in the opposite direction, from server to client, to communicate changes to a zone. The client subscribes for Push Notifications by connecting to the server and sending DNS message(s) indicating the RRSet(s) of interest. When the client loses interest in updates to these records, it unsubscribes.</p>
<p id="rfc.section.3.p.3">The DNS Push Notification server for a zone is any server capable<br/> of generating the correct change notifications for a name.<br/> It may be a master, slave, or stealth name server <a href="#RFC7719">[RFC7719]</a>.  Consequently, the <samp>_dns&#8209;push&#8209;tls._tcp.&lt;zone&gt;</samp> SRV record for a<br/> zone MAY reference the same target host and port as that zone's <samp>_dns&#8209;update&#8209;tls._tcp.&lt;zone&gt;</samp> SRV record. When the same target host and port is offered for both DNS Updates and DNS Push Notifications, a client MAY use a single TCP connection to that server for both DNS Updates and DNS Push Notification Queries.</p>
<p id="rfc.section.3.p.4">Supporting DNS Updates and DNS Push Notifications on the same server is OPTIONAL. A DNS Push Notification server does NOT also have to support DNS Update.</p>
<p id="rfc.section.3.p.5">DNS Updates and DNS Push Notifications may be handled on different ports on the same target host, in which case they are not considered to be the "same server" for the purposes of this specification, and communications with these two ports are handled independently.</p>
<p id="rfc.section.3.p.6">Standard DNS Queries MAY be sent over a DNS Push Notification connection, provided that these are queries for names falling within the server's zone (the &lt;zone&gt; in the <samp>_dns&#8209;push&#8209;tls._tcp.&lt;zone&gt;</samp> SRV record). The RD (Recursion Desired) bit MUST be zero. If a query is received with the RD bit set, matching records for names falling within the server's zones should be returned with the RA (Recursion Available) bit clear. If the query is for a name not in the server's zone, an error with RCODE NOTAUTH (Not Authoritative) should be returned.</p>
<p id="rfc.section.3.p.7">DNS Push Notification clients are NOT required to implement DNS Update Prerequisite processing. Prerequisites are used to perform tentative atomic test-and-set type operations when a client updates records on a server, and that concept has no applicability when it comes to an authoritative server informing a client of changes to DNS records.</p>
<p id="rfc.section.3.p.8">This DNS Push Notification specification includes support for DNS classes, for completeness. However, in practice, it is anticipated that for the foreseeable future the only DNS class in use will be DNS class "IN", as is the reality today with existing DNS servers and clients. A DNS Push Notification server MAY choose to implement only DNS class "IN". If messages are received for a class other than "IN", and that class is not supported, an error with RCODE NOTIMPL (Not Implemented) should be returned.</p>
<p id="rfc.section.3.p.9">DNS Push Notifications impose less load on the responding server than rapid polling would, but Push Notifications do still have a cost, so DNS Push Notification clients must not recklessly create an excessive number of Push Notification subscriptions. A subscription should only be active when there is a valid reason to need live data (for example, an on-screen display is currently showing the results to the user) and the subscription SHOULD be cancelled as soon as the need for that data ends (for example, when the user dismisses that display). Implementations MAY want to implement idle timeouts, so that if the user ceases interacting with the device, the display showing the result of the DNS Push Notification subscription is automatically dismissed after a certain period of inactivity. For example, if a user presses the "Print" button on their smartphone, and then leaves the phone showing the printer discovery screen until the phone goes to sleep, then the printer discovery screen should be automatically dismissed as the device goes to sleep. If the user does still intend to print, this will require them to press the "Print" button again when they wake their phone up.</p>
<p id="rfc.section.3.p.10">A DNS Push Notification client must not routinely keep a DNS Push Notification subscription active 24 hours a day, 7 days a week, just to keep a list in memory up to date so that if the user does choose to bring up an on-screen display of that data, it can be displayed really fast. DNS Push Notifications are designed to be fast enough that there is no need to pre-load a "warm" list in memory just in case it might be needed later.</p>
<p id="rfc.section.3.p.11">Generally, as described in the <a href="#SessSig">DNS Session Signaling specification</a> <cite title="NONE">[SessSig]</cite>, a client must not keep a connection to a server open indefinitely if it has no subscriptions (or other operations) active on that connection. A client MAY close a connection as soon as it becomes idle, and then if needed in the future, open a new connection when required. Alternatively, a client MAY speculatively keep an idle connection open for some time, subject to the constraint that it MUST NOT keep a connection open that has been idle for more than the session's idle timeout (15 seconds by default).</p>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> Transport</h1>
<p id="rfc.section.4.p.1">Implementations of <a href="#RFC2136">DNS Update</a> <cite title="NONE">[RFC2136]</cite> MAY use either User Datagram Protocol <a href="#RFC0768">(UDP)</a> <cite title="NONE">[RFC0768]</cite> or Transmission Control Protocol <a href="#RFC0793">(TCP)</a> <cite title="NONE">[RFC0793]</cite> as the transport protocol, in keeping with the historical precedent that DNS queries must first be sent over UDP <a href="#RFC1123">[RFC1123]</a>. This requirement to use UDP has subsequently been relaxed <a href="#RFC7766">[RFC7766]</a>.</p>
<p id="rfc.section.4.p.2">In keeping with the more recent precedent, DNS Push Notification is defined only for TCP. DNS Push Notification clients MUST use TLS over TCP, <a href="#RFC7858">see RFC 7858</a> <cite title="NONE">[RFC7858]</cite>.</p>
<p id="rfc.section.4.p.3">Connection setup over TCP ensures return reachability and alleviates concerns of state overload at the server through anonymous subscriptions. All subscribers are guaranteed to be reachable by the server by virtue of the TCP three-way handshake.  Flooding attacks are possible with any protocol, and a benefit of TCP is that there are already established industry best practices to guard against SYN flooding and similar attacks <a href="#IPJ.9-4-TCPSYN">[IPJ.9-4-TCPSYN]</a> <a href="#RFC4953">[RFC4953]</a>.</p>
<p id="rfc.section.4.p.4">Use of TCP also allows DNS Push Notifications to take advantage of current and future developments in TCP, such as <a href="#RFC6824">Multipath TCP (MPTCP)</a> <cite title="NONE">[RFC6824]</cite>, <a href="#RFC7413">TCP Fast Open (TFO)</a> <cite title="NONE">[RFC7413]</cite>, <a href="#I-D.dukkipati-tcpm-tcp-loss-probe">Tail Loss Probe (TLP)</a> <cite title="NONE">[I-D.dukkipati-tcpm-tcp-loss-probe]</cite>, and so on.</p>
<p id="rfc.section.4.p.5">Transport Layer Security <a href="#RFC5246">(TLS)</a> <cite title="NONE">[RFC5246]</cite> is well understood and deployed across many protocols running over TCP. It is designed to prevent eavesdropping, tampering, or message forgery. TLS is REQUIRED for every connection between a client subscriber and server in this protocol specification. Additional security measures such as client authentication during TLS negotiation MAY also be employed to increase the trust relationship between client and server.</p>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> State Considerations</h1>
<p id="rfc.section.5.p.1">Each DNS Push Notification server is capable of handling some finite number of Push Notification subscriptions. This number will vary from server to server and is based on physical machine characteristics, network bandwidth, and operating system resource allocation. After a client establishes a connection to a DNS server, each subscription is individually accepted or rejected. Servers may employ various techniques to limit subscriptions to a manageable level. Correspondingly, the client is free to establish simultaneous connections to alternate DNS servers that support DNS Push Notifications for the zone and distribute subscriptions at its discretion. In this way, both clients and servers can react to resource constraints. Token bucket rate limiting schemes are also effective in providing fairness by a server across numerous client requests.</p>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> Protocol Operation</h1>
<p id="rfc.section.6.p.1">The DNS Push Notification protocol is a session-oriented protocol, and makes use of <a href="#SessSig">DNS Session Signaling</a> <cite title="NONE">[SessSig]</cite>.</p>
<p id="rfc.section.6.p.2">For details of the DNS Session Signaling message format refer to the <a href="#SessSig">DNS Session Signaling specification</a> <cite title="NONE">[SessSig]</cite>.  Those details are not repeated here.</p>
<p id="rfc.section.6.p.3">DNS Push Notification clients and servers MUST support DNS Session Signaling, but the server SHOULD NOT issue any DNS Session Signaling operations until after the client has first initiated a DNS Session Signaling operation of its own.  A single server can support DNS Queries, DNS Updates, and DNS Push Notifications (using DNS Session Signaling) on the same TCP port, and until the client has sent at least one DNS Session Signaling operation the server does not know what kind of client has connected to it.  Once the client has indicated willingness to use DNS Session Signaling operations by sending one of its own, either side of the connection may then initiate further Session Signaling operations at any time.</p>
<p id="rfc.section.6.p.4">A DNS Push Notification exchange begins with the client discovering the appropriate server, using the procedure described in <a href="#discovery">Section 6.1</a>, and then making a TLS/TCP connection to it.</p>
<p id="rfc.section.6.p.5">A typical DNS Push Notification client will immediately issue a DNS Session Signaling Keepalive operation to request a session timeout or keepalive interval longer than the the 15-second defaults, but this is not required.  A DNS Push Notification client MAY issue other requests on the connection first, and only issue a DNS Session Signaling Keepalive operation later if it determines that to be necessary.</p>
<p id="rfc.section.6.p.6">Once the connection is made, the client may then add and remove Push Notification subscriptions. In accordance with the current set of active subscriptions the server sends relevant asynchronous Push Notifications to the client. Note that a client MUST be prepared to receive (and silently ignore) Push Notifications for subscriptions it has previously removed, since there is no way to prevent the situation where a Push Notification is in flight from server to client while the client's UNSUBSCRIBE message cancelling that subscription is simultaneously in flight from client to server.</p>
<p id="rfc.section.6.p.7">The exchange between client and server terminates when either end closes the TCP connection with a TCP FIN or RST.</p>
<h1 id="rfc.section.6.1"><a href="#rfc.section.6.1">6.1.</a> <a href="#discovery" id="discovery">Discovery</a></h1>
<p id="rfc.section.6.1.p.1">The first step in DNS Push Notification subscription is to discover an appropriate DNS server that supports DNS Push Notifications for the desired zone. The client MUST also determine which TCP port on the server is listening for connections, which need not be (and often is not) the typical TCP port 53 used for conventional DNS, or TCP port 853 used for <a href="#RFC7858">DNS over TLS</a> <cite title="NONE">[RFC7858]</cite>.</p>
<p/>

<ol>
  <li>The client begins the discovery by sending a DNS query to its local resolver, with record type <a href="#RFC1035">SOA</a> <cite title="NONE">[RFC1035]</cite> for the record to which it wishes to subscribe. As an example, if it wishes to subscribe to PTR records with the name _printers._tcp.foo.example.com, it sends an SOA query for _printers._tcp.foo.example.com. The goal is to determine the authoritative server for foo.example.com.</li>
  <li>If the SOA record exists as exactly specified in the query, it is expected to be returned in the Answer section with a NOERROR response code. If the exact SOA record does not exist, the client may get back a NOERROR/NODATA response or it may get back a NXDOMAIN/Name Error response. This depends on the resolver implementation and whether the domain exists. The client is looking for an SOA record to be returned in either the Answer section or the Authority section with a NOERROR response code. If the client receives an NXDOMAIN/Name Error response code, it should strip the leading label from the query name and if the resulting name has at least one label in it, the client should send a new SOA query, repeating this until a NOERROR response code is received or the query name is empty. In the case of an empty name, the client may retry the operation at a later time, of the client's choosing, such after a change in network attachment.</li>
  <li>In the example above, if an SOA record query is sent for _printers._tcp.foo.example.com and an NXDOMAIN/Name Error is returned with an SOA record in the Authority section for foo.example.com, the client should strip the leading label and query an SOA record for _tcp.foo.example.com. If a NOERROR/NODATA response is received with an SOA record in the Authority section for foo.example.com, this is sufficent. If an NXDOMAIN/Name Error response is received, the client should again strip the leading label and query an SOA record for foo.example.com. If the foo.example.com domain exists, this should result in a NOERROR response with the SOA record in the Answer section. If the domain foo.example.com does not exist, the response will likely be an NXDOMAIN/Name Error with an SOA record for example.com in the Authority section. This means the subdomain foo.example.com has not been properly delegated by example.com.</li>
  <li>If a NOERROR/NODATA response is received but contains no SOA in the Authority section, the client could try stripping the leading label and issuing another SOA query. Additional information about negative responses can be found in Section 2 of <a href="#RFC2308">[RFC2308]</a>.</li>
  <li>Once the SOA is known (either by virtue of being seen in the Answer Section, or in the Authority Section), the client sends a DNS query with type <a href="#RFC2782">SRV</a> <cite title="NONE">[RFC2782]</cite> for the record name <samp>_dns&#8209;push&#8209;tls._tcp.&lt;zone&gt;</samp>, where &lt;zone&gt; is the owner name of the discovered SOA record.</li>
  <li>For implementors of this specification, an authoritative answer for that SRV record, and only such an answer, will determine whether the zone supports DNS Push Notifications.</li>
  <li>If the SRV record does exist, the SRV <samp>target</samp> contains the name of the server providing DNS Push Notifications for the zone. The port number on which to contact the server is in the SRV record <samp>port</samp> field. The address(es) of the target host MAY be included in the Additional Section, however, the address records SHOULD be authenticated before use as described below in <a href="#tls_name_auth">Section 7.2</a> and <a href="#RFC7673">[RFC7673]</a>.</li>
  <li>More than one SRV record may be returned. In this case, the <samp>priority</samp> and <samp>weight</samp> values in the returned SRV records are used to determine the order in which to contact the servers for subscription requests. As described in <a href="#RFC2782">the SRV specification</a> <cite title="NONE">[RFC2782]</cite>, the server with the lowest <samp>priority</samp> is first contacted. If more than one server has the same <samp>priority</samp>, the <samp>weight</samp> indicates the weighted probability that the client should contact that server. Higher weights have higher probabilities of being selected. If a server is not reachable or is not willing to accept a subscription request, then a subsequent server is to be contacted.</li>
</ol>

<p> </p>
<p id="rfc.section.6.1.p.3">Each time a client makes a new DNS Push Notification subscription connection, it SHOULD repeat the discovery process in order to determine the preferred DNS server for subscriptions at that time. However, the client device MUST respect the DNS TTL values on records it receives, and store them in its local cache with this lifetime. This means that, as long as the DNS TTL values on the authoritative records were set to reasonable values, repeated application of this discovery process can be completed nearly instantaneously by the client, using only locally-stored cached data.</p>
<h1 id="rfc.section.6.2"><a href="#rfc.section.6.2">6.2.</a> DNS Push Notification SUBSCRIBE</h1>
<p id="rfc.section.6.2.p.1">After connecting, and requesting a longer idle timeout and/or keepalive interval if necessary, a DNS Push Notification client then indicates its desire to receive DNS Push Notifications for a given domain name by sending a SUBSCRIBE request over the established TLS connection to the server. A SUBSCRIBE request is encoded in a <a href="#SessSig">DNS Session Signaling</a> <cite title="NONE">[SessSig]</cite> message. This specification defines a DNS Session Signaling TLV for DNS Push Notification SUBSCRIBE Requests/Responses (tentatively Session Signaling Type Code 0x40).</p>
<p id="rfc.section.6.2.p.2">The entity that initiates a SUBSCRIBE request is by definition the client. A server should not send a SUBSCRIBE request over an existing connection from a client. If a server does send a SUBSCRIBE request over the connection initiated by a client, it is an error and the client should acknowledge the request with the error response RCODE NOTAUTH (Not Authoritative).</p>
<h1 id="rfc.section.6.2.1"><a href="#rfc.section.6.2.1">6.2.1.</a> SUBSCRIBE Request</h1>
<p id="rfc.section.6.2.1.p.1">A SUBSCRIBE request message begins with the standard <a href="#SessSig">DNS Session Signaling 12-byte header</a> <cite title="NONE">[SessSig]</cite>, followed by the SUBSCRIBE TLV.  A SUBSCRIBE request message is illustrated below:</p>
<div id="rfc.figure.1"/>
<div id="subscribe_req"/>
<pre>
                                1  1  1  1  1  1
  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                  MESSAGE ID                   |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|QR|  Opcode   |         Z          |   RCODE   |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|             QDCOUNT (MUST BE ZERO)            |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|             ANCOUNT (MUST BE ZERO)            |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|             NSCOUNT (MUST BE ZERO)            |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|             ARCOUNT (MUST BE ZERO)            |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|   SSOP-TYPE = SUBSCRIBE (tentatively 0x40)    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|  SSOP-LENGTH (number of octets in SSOP-DATA)  |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+  \
|                                               |   \
\                     NAME                      \    |
\                                               \    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+     &gt; SSOP-DATA
|                     TYPE                      |    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    |
|                     CLASS                     |   /
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+  /</pre>
<p class="figure">Figure 1</p>
<p id="rfc.section.6.2.1.p.2">The MESSAGE ID field MUST be set to a unique value, that the client is not using for any other active operation on this connection. For the purposes here, a MESSAGE ID is in use on this connection if the client has used it in a request for which it has not yet received a response, or if the client has used it for a subscription which it has not yet cancelled using UNSUBSCRIBE. In the SUBSCRIBE response the server MUST echo back the MESSAGE ID value unchanged.</p>
<p id="rfc.section.6.2.1.p.3">The other header fields MUST be set as described in the <a href="#SessSig">DNS Session Signaling specification</a> <cite title="NONE">[SessSig]</cite>.  The DNS Opcode is the Session Signaling Opcode (tentatively 6).  The four count fields MUST be empty, and the corresponding four sections MUST be empty (i.e., absent).</p>
<p id="rfc.section.6.2.1.p.4">The SSOP-TYPE is SUBSCRIBE (tentatively 0x40).  The SSOP-LENGTH is the length of the SSOP-DATA that follows, which specifies the name, type, and class of the record(s) being sought.</p>
<p id="rfc.section.6.2.1.p.5">The SSOP-DATA for a SUBSCRIBE request MUST contain exactly one question.  The SSOP-DATA for a SUBSCRIBE request has no QDCOUNT field to specify more than one question.  Since SUBSCRIBE requests are sent over TCP, multiple SUBSCRIBE request messages can be concatenated in a single TCP stream and packed efficiently into TCP segments.</p>
<p id="rfc.section.6.2.1.p.6">If accepted, the subscription will stay in effect until the client cancels the subscription using UNSUBSCRIBE or until the connection between the client and the server is closed.</p>
<p id="rfc.section.6.2.1.p.7">SUBSCRIBE requests on a given connection MUST be unique. A client MUST NOT send a SUBSCRIBE message that duplicates the NAME, TYPE and CLASS of an existing active subscription on that TLS/TCP connection. For the purpose of this matching, the established DNS case-insensitivity for US-ASCII letters applies (e.g., "foo.com" and "Foo.com" are the same). If a server receives such a duplicate SUBSCRIBE message this is an error and the server MUST immediately terminate the connection with a TCP RST (or equivalent for other protocols).</p>
<p id="rfc.section.6.2.1.p.8">DNS wildcarding is not supported. That is, a wildcard ("*") in a SUBSCRIBE message matches only a literal wildcard character ("*") in the zone, and nothing else.</p>
<p id="rfc.section.6.2.1.p.9">Aliasing is not supported. That is, a CNAME in a SUBSCRIBE message matches only a literal CNAME record in the zone, and nothing else.</p>
<p id="rfc.section.6.2.1.p.10">A client may SUBSCRIBE to records that are unknown to the server at the time of the request (providing that the name falls within one of the zone(s) the server is responsible for) and this is not an error. The server MUST accept these requests and send Push Notifications if and when matching records are found in the future.</p>
<p id="rfc.section.6.2.1.p.11">If neither TYPE nor CLASS are ANY (255) then this is a specific subscription to changes for the given NAME, TYPE and CLASS. If one or both of TYPE or CLASS are ANY (255) then this subscription matches any type and/or any class, as appropriate.</p>
<p id="rfc.section.6.2.1.p.12">NOTE: A little-known quirk of DNS is that in DNS QUERY requests, QTYPE and QCLASS 255 mean "ANY" not "ALL". They indicate that the server should respond with ANY matching records of its choosing, not necessarily ALL matching records. This can lead to some surprising and unexpected results, where a query returns some valid answers but not all of them, and makes QTYPE=ANY queries less useful than people sometimes imagine.</p>
<p id="rfc.section.6.2.1.p.13">When used in conjunction with SUBSCRIBE, TYPE and CLASS 255 should be interpreted to mean "ALL", not "ANY". After accepting a subscription where one or both of TYPE or CLASS are 255, the server MUST send Push Notification Updates for ALL record changes that match the subscription, not just some of them.</p>
<h1 id="rfc.section.6.2.2"><a href="#rfc.section.6.2.2">6.2.2.</a> SUBSCRIBE Response</h1>
<p id="rfc.section.6.2.2.p.1">Each SUBSCRIBE request generates exactly one SUBSCRIBE response from the server.</p>
<p id="rfc.section.6.2.2.p.2">A SUBSCRIBE response message begins with the standard <a href="#SessSig">DNS Session Signaling 12-byte header</a> <cite title="NONE">[SessSig]</cite>, possibly followed by one or more optional Modifier TLVs, such as a Retry Delay Modifier TLV.</p>
<p id="rfc.section.6.2.2.p.3">The MESSAGE ID field MUST echo the value given in the ID field of the SUBSCRIBE request.  This is how the client knows which request is being responded to.</p>
<p id="rfc.section.6.2.2.p.4">A SUBSCRIBE response message MUST NOT contain a Session Signaling Operation TLV.  The Session Signaling Operation TLV is NOT copied from the SUBSCRIBE request.</p>
<p id="rfc.section.6.2.2.p.5">In the SUBSCRIBE response the RCODE indicates whether or not the subscription was accepted. Supported RCODEs are as follows:</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
  <caption>SUBSCRIBE Response codes</caption>
  <thead>
    <tr>
      <th class="left">Mnemonic</th>
      <th class="center">Value</th>
      <th class="left">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="left">NOERROR</td>
      <td class="center">0</td>
      <td class="left">SUBSCRIBE successful.</td>
    </tr>
    <tr>
      <td class="left">FORMERR</td>
      <td class="center">1</td>
      <td class="left">Server failed to process request due to a malformed request.</td>
    </tr>
    <tr>
      <td class="left">SERVFAIL</td>
      <td class="center">2</td>
      <td class="left">Server failed to process request due to a problem with the server.</td>
    </tr>
    <tr>
      <td class="left">NXDOMAIN</td>
      <td class="center">3</td>
      <td class="left">NOT APPLICABLE. DNS Push Notification servers MUST NOT return NXDOMAIN errors in response to SUBSCRIBE requests.</td>
    </tr>
    <tr>
      <td class="left">NOTIMP</td>
      <td class="center">4</td>
      <td class="left">Server does not recognize DNS Session Signaling Opcode.</td>
    </tr>
    <tr>
      <td class="left">REFUSED</td>
      <td class="center">5</td>
      <td class="left">Server refuses to process request for policy or security reasons.</td>
    </tr>
    <tr>
      <td class="left">NOTAUTH</td>
      <td class="center">9</td>
      <td class="left">Server is not authoritative for the requested name.</td>
    </tr>
    <tr>
      <td class="left">SSOPNOTIMP</td>
      <td class="center">11</td>
      <td class="left">SUBSCRIBE operation not supported.</td>
    </tr>
  </tbody>
</table>
<p id="rfc.section.6.2.2.p.6">This document specifies only these RCODE values for SUBSCRIBE Responses. Servers sending SUBSCRIBE Responses SHOULD use one of these values. However, future circumstances may create situations where other RCODE values are appropriate in SUBSCRIBE Responses, so clients MUST be prepared to accept SUBSCRIBE Responses with any RCODE value.</p>
<p id="rfc.section.6.2.2.p.7">If the server sends a nonzero RCODE in the SUBSCRIBE response, either the client is (at least partially) misconfigured, the server resources are exhausted, or there is some other unknown failure on the server. In any case, the client shouldn't retry the subscription right away. Either end can terminate the connection, but the client may want to try this subscription again or it may have other successful subscriptions that it doesn't want to abandon. If the server sends a nonzero RCODE then it SHOULD append a Retry Delay Modifier TLV <a href="#SessSig">[SessSig]</a> to the response specifying a delay before the client attempts this operation again. Recommended values for the delay for different RCODE values are given below: </p>

<ul class="empty">
  <li>For RCODE = 1 (FORMERR) the delay may be any value selected by the implementer. A value of five minutes is RECOMMENDED, to reduce the risk of high load from defective clients.</li>
  <li>For RCODE = 2 (SERVFAIL) the delay should be chosen according to the level of server overload and the anticipated duration of that overload. By default, a value of one minute is RECOMMENDED. If a more serious server failure occurs, the delay may be longer in accordance with the specific problem encountered.</li>
  <li>For RCODE = 4 (NOTIMP), which occurs on a server that doesn't implement <a href="#SessSig">DNS Session Signaling</a> <cite title="NONE">[SessSig]</cite>, it is unlikely that the server will begin supporting DNS Session Signaling in the next few minutes, so the retry delay SHOULD be one hour.</li>
  <li>For RCODE = 5 (REFUSED), which occurs on a server that implements DNS Push Notifications, but is currently configured to disallow DNS Push Notifications, the retry delay may be any value selected by the implementer and/or configured by the operator.<br/> This is a misconfiguration, since this server is listed in a <samp>_dns&#8209;push&#8209;tls._tcp.&lt;zone&gt;</samp> SRV record, but the server itself is not currently configured to support DNS Push Notifications. Since it is possible that the misconfiguration may be repaired at any time, the retry delay should not be set too high. By default, a value of 5 minutes is RECOMMENDED.</li>
  <li>For RCODE = 9 (NOTAUTH), which occurs on a server that implements DNS Push Notifications, but is not configured to be authoritative for the requested name, the retry delay may be any value selected by the implementer and/or configured by the operator.  <br/>This is a misconfiguration, since this server is listed in a <samp>_dns&#8209;push&#8209;tls._tcp.&lt;zone&gt;</samp> SRV record, but the server itself is not currently configured to support DNS Push Notifications for that zone. Since it is possible that the misconfiguration may be repaired at any time, the retry delay should not be set too high. By default, a value of 5 minutes is RECOMMENDED.</li>
  <li>For RCODE = 11 (DNS Push SUBSCRIBE operation not supported), which occurs on a server that doesn't implement DNS Push Notifications, it is unlikely that the server will begin supporting DNS Push Notifications in the next few minutes, so the retry delay SHOULD be one hour.</li>
  <li>For other RCODE values, the retry delay should be set by the server as appropriate for that error condition. By default, a value of 5 minutes is RECOMMENDED.</li>
</ul>

<p> </p>
<p id="rfc.section.6.2.2.p.8">For RCODE = 9 (NOTAUTH), the time delay applies to requests for other names falling within the same zone. Requests for names falling within other zones are not subject to the delay. For all other RCODEs the time delay applies to all subsequent requests to this server.</p>
<p id="rfc.section.6.2.2.p.9">After sending an error response the server MAY allow the connection to remain open, or MAY send a DNS Push Notification Retry Delay Operation TLV asserting the client close the TCP connection, as described in the <a href="#SessSig">DNS Session Signaling specification</a> <cite title="NONE">[SessSig]</cite>.  Clients MUST correctly handle both cases.</p>
<h1 id="rfc.section.6.3"><a href="#rfc.section.6.3">6.3.</a> DNS Push Notification Updates</h1>
<p id="rfc.section.6.3.p.1">Once a subscription has been successfully established, the server generates PUSH messages to send to the client as appropriate. In the case that the answer set was non-empty at the moment the subscription was established, an initial PUSH message will be sent immediately following the SUBSCRIBE Response. Subsequent changes to the answer set are then communicated to the client in subsequent PUSH messages.</p>
<h1 id="rfc.section.6.3.1"><a href="#rfc.section.6.3.1">6.3.1.</a> PUSH Message</h1>
<p id="rfc.section.6.3.1.p.1">A PUSH message begins with the standard <a href="#SessSig">DNS Session Signaling 12-byte header</a> <cite title="NONE">[SessSig]</cite>, followed by the PUSH TLV.  A PUSH message is illustrated below:</p>
<div id="rfc.figure.2"/>
<div id="push_msg"/>
<pre>
                                1  1  1  1  1  1
  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                  MESSAGE ID                   |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|QR|  Opcode   |         Z          |   RCODE   |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|             QDCOUNT (MUST BE ZERO)            |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|             ANCOUNT (MUST BE ZERO)            |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|             NSCOUNT (MUST BE ZERO)            |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|             ARCOUNT (MUST BE ZERO)            |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|      SSOP-TYPE = PUSH (tentatively 0x42)      |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|  SSOP-LENGTH (number of octets in SSOP-DATA)  |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+  \
\                     NAME                      \   \
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    |
|                     TYPE                      |    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    |
|                     CLASS                     |    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    |
|                     RDLEN                     |    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    |
\                     RDATA                     \    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+     &gt; SSOP-DATA
\         NAME                                  \    |
+--+--+--+--+--+--+-                            |    |
|         TYPE                Repeated          |    |
+--+--+--+--+--+--+-                            |    |
|         CLASS                  As             |    |
+--+--+--+--+--+--+-                            |    |
|         RDLEN               Necessary         |    |
+--+--+--+--+--+--+-                            |    |
\         RDATA                                 \   /
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+  /</pre>
<p class="figure">Figure 2</p>
<p id="rfc.section.6.3.1.p.2">The MESSAGE ID field MUST be set to a unique value, that the server is not currently using for any other active outgoing request that it has sent on this connection. The MESSAGE ID in the outgoing PUSH message is selected by the server and has no relationship to the MESSAGE ID in any of the client subscriptions it may relate to. In the PUSH response the client MUST echo back the MESSAGE ID value unchanged.</p>
<p id="rfc.section.6.3.1.p.3">The other header fields MUST be set as described in the <a href="#SessSig">DNS Session Signaling specification</a> <cite title="NONE">[SessSig]</cite>.  The DNS Opcode is the Session Signaling Opcode (tentatively 6).  The four count fields MUST be empty, and the corresponding four sections MUST be empty (i.e., absent).</p>
<p id="rfc.section.6.3.1.p.4">The SSOP-TYPE is PUSH (tentatively 0x41).  The SSOP-LENGTH is the length of the SSOP-DATA that follows, which specifies the changes being communicated.</p>
<p id="rfc.section.6.3.1.p.5">The SSOP-DATA contains one or more Update records.  A PUSH Message MUST contain at least one Update record.  If a PUSH Message is received that contains no Update records, this is a fatal error, and the receiver MUST immediately terminate the connection with a TCP RST (or equivalent for other protocols).  The Update records are formatted in the customary way for Resource Records in DNS messages with the stipulation that DNS name compression is not permitted in DNS Session Signaling TLVs.  Update records in a PUSH Message are interpreted according to the same rules as for <a href="#RFC2136">DNS Update</a> <cite title="NONE">[RFC2136]</cite> messages, namely: </p>

<ul class="empty">
  <li>Delete all RRsets from a name:<br/> TTL=0, CLASS=ANY, RDLENGTH=0, TYPE=ANY.</li>
  <li>Delete an RRset from a name:<br/> TTL=0, CLASS=ANY, RDLENGTH=0;<br/> TYPE specifies the RRset being deleted.</li>
  <li>Delete an individual RR from a name:<br/> TTL=0, CLASS=NONE;<br/> TYPE, RDLENGTH and RDATA specifies the RR being deleted.</li>
  <li>Add to an RRset:<br/> TTL, CLASS, TYPE, RDLENGTH and RDATA specifies the RR being added.</li>
</ul>

<p> </p>
<p id="rfc.section.6.3.1.p.6">When processing the records received in a PUSH Message, the receiving client MUST validate that the records being added or deleted correspond with at least one currently active subscription on that connection. Specifically, the record name MUST match the name given in the SUBSCRIBE request, subject to the usual established DNS case-insensitivity for US-ASCII letters.  If the TYPE in the SUBSCRIBE request was not ANY (255) then the TYPE of the record must match the TYPE given in the SUBSCRIBE request.  If the CLASS in the SUBSCRIBE request was not ANY (255) then the CLASS of the record must match the CLASS given in the SUBSCRIBE request.  If a matching active subscription on that connection is not found, then that individual record addition/deletion is silently ignored. Processing of other additions and deletions in this message is not affected. The TCP connection is not closed. This is to allow for the unavoidable race condition where a client sends an outbound UNSUBSCRIBE while inbound PUSH messages for that subscription from the server are still in flight.</p>
<p id="rfc.section.6.3.1.p.7">In the case where a single change affects more than one active subscription, only one PUSH message is sent. For example, a PUSH message adding a given record may match both a SUBSCRIBE request with the same TYPE and a different SUBSCRIBE request with TYPE=ANY. It is not the case that two PUSH messages are sent because the new record matches two active subscriptions.</p>
<p id="rfc.section.6.3.1.p.8">The server SHOULD encode change notifications in the most efficient manner possible. For example, when three AAAA records are deleted from a given name, and no other AAAA records exist for that name, the server SHOULD send a "delete an RRset from a name" PUSH message, not three separate "delete an individual RR from a name" PUSH messages. Similarly, when both an SRV and a TXT record are deleted from a given name, and no other records of any kind exist for that name, the server SHOULD send a "delete all RRsets from a name" PUSH message, not two separate "delete an RRset from a name" PUSH messages.</p>
<p id="rfc.section.6.3.1.p.9">A server SHOULD combine multiple change notifications in a single PUSH message when possible, even if those change notifications apply to different subscriptions. Conceptually, a PUSH message is a connection-level mechanism, not a subscription-level mechanism.</p>
<p id="rfc.section.6.3.1.p.10">Reception of a PUSH message by a client generates a PUSH response back to the server.</p>
<p id="rfc.section.6.3.1.p.11">The TTL of an added record is stored by the client and decremented as time passes, with the caveat that for as long as a relevant subscription is active, the TTL does not decrement below 1 second. For as long as a relevant subscription remains active, the client SHOULD assume that when a record goes away the server will notify it of that fact. Consequently, a client does not have to poll to verify that the record is still there. Once a subscription is cancelled (individually, or as a result of the TCP connection being closed) record aging resumes and records are removed from the local cache when their TTL reaches zero.</p>
<h1 id="rfc.section.6.3.2"><a href="#rfc.section.6.3.2">6.3.2.</a> PUSH Response</h1>
<p id="rfc.section.6.3.2.p.1">Each PUSH message generates exactly one PUSH response from the receiver.</p>
<p id="rfc.section.6.3.2.p.2">A PUSH response message begins with the standard <a href="#SessSig">DNS Session Signaling 12-byte header</a> <cite title="NONE">[SessSig]</cite>, possibly followed by one or more optional Modifier TLVs, such as a Retry Delay Modifier TLV.</p>
<p id="rfc.section.6.3.2.p.3">The MESSAGE ID field MUST echo the value given in the ID field of the PUSH message.</p>
<p id="rfc.section.6.3.2.p.4">A PUSH response message MUST NOT contain a Session Signaling Operation TLV.  The Session Signaling Operation TLV is NOT copied from the PUSH message.</p>
<p id="rfc.section.6.3.2.p.5">In a PUSH response the RCODE MUST be zero. Receiving a PUSH response with a nonzero RCODE is a fatal error, and the receiver MUST immediately terminate the connection with a TCP RST (or equivalent for other protocols).</p>
<h1 id="rfc.section.6.4"><a href="#rfc.section.6.4">6.4.</a> DNS Push Notification UNSUBSCRIBE</h1>
<p id="rfc.section.6.4.p.1">To cancel an individual subscription without closing the entire connection, the client sends an UNSUBSCRIBE message over the established TCP connection to the server. The UNSUBSCRIBE message is encoded in a <a href="#SessSig">DNS Session Signaling</a> <cite title="NONE">[SessSig]</cite> message. This specification defines a DNS Session Signaling TLV for DNS Push Notification UNSUBSCRIBE Requests/Responses (tentatively Session Signaling Type Code 0x42).</p>
<p id="rfc.section.6.4.p.2">A server MUST NOT initiate an UNSUBSCRIBE request. If a server does send a UNSUBSCRIBE request over the connection initiated by a client, it is an error and the client should acknowledge the request with the error response RCODE NOTAUTH (Not Authoritative).</p>
<h1 id="rfc.section.6.4.1"><a href="#rfc.section.6.4.1">6.4.1.</a> UNSUBSCRIBE Request</h1>
<p id="rfc.section.6.4.1.p.1">An UNSUBSCRIBE request message begins with the standard <a href="#SessSig">DNS Session Signaling 12-byte header</a> <cite title="NONE">[SessSig]</cite>, followed by the UNSUBSCRIBE TLV.</p>
<div id="rfc.figure.3"/>
<div id="unsubscribe_req"/>
<pre>
                                1  1  1  1  1  1
  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                  MESSAGE ID                   |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|QR|  Opcode   |         Z          |   RCODE   |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|             QDCOUNT (MUST BE ZERO)            |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|             ANCOUNT (MUST BE ZERO)            |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|             NSCOUNT (MUST BE ZERO)            |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|             ARCOUNT (MUST BE ZERO)            |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|  SSOP-TYPE = UNSUBSCRIBE (tentatively 0x42)   |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|             SSOP-LENGTH (2 octets)            |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|              SUBSCRIBE MESSAGE ID             |   SSOP-DATA
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</pre>
<p class="figure">Figure 3</p>
<p id="rfc.section.6.4.1.p.2">In the UNSUBSCRIBE TLV the SSOP-TYPE is UNSUBSCRIBE (tentatively 0x42).  The SSOP-LENGTH is 2 octets.</p>
<p id="rfc.section.6.4.1.p.3">The SSOP-DATA contains the MESSAGE ID field of the value given in the ID field of an active SUBSCRIBE request.  This is how the server knows which SUBSCRIBE request is being cancelled.  After receipt of the UNSUBSCRIBE request, the SUBSCRIBE request is no longer active.  If a server receives an UNSUBSCRIBE message where the MESSAGE ID does not match the ID of an active SUBSCRIBE request the server MUST return a response containing RCODE = 3 (NXDOMAIN).</p>
<p id="rfc.section.6.4.1.p.4">It is allowable for the client to issue an UNSUBSCRIBE request for a previous SUBSCRIBE request for which the client has not yet received a SUBSCRIBE response.  This is to allow for the case where a client starts and stops a subscription in less than the round-trip time to the server.  The client is NOT required to wait for the SUBSCRIBE response before issuing the UNSUBSCRIBE request.  A consequence of this is that if the client issues an UNSUBSCRIBE request for an as-yet unacknowledged SUBSCRIBE request, and the SUBSCRIBE request is subsequently unsuccessful for some reason, then when the UNSUBSCRIBE request is eventually processed it will be an UNSUBSCRIBE request for a nonexistent subscription, which will result NXDOMAIN response.</p>
<h1 id="rfc.section.6.4.2"><a href="#rfc.section.6.4.2">6.4.2.</a> UNSUBSCRIBE Response</h1>
<p id="rfc.section.6.4.2.p.1">Each UNSUBSCRIBE request generates exactly one UNSUBSCRIBE response from the server.</p>
<p id="rfc.section.6.4.2.p.2">An UNSUBSCRIBE response message begins with the standard <a href="#SessSig">DNS Session Signaling 12-byte header</a> <cite title="NONE">[SessSig]</cite>, possibly followed by one or more optional Modifier TLVs, such as a Retry Delay Modifier TLV.</p>
<p id="rfc.section.6.4.2.p.3">The MESSAGE ID field MUST echo the value given in the ID field of the UNSUBSCRIBE request.  This is how the client knows which request is being responded to.</p>
<p id="rfc.section.6.4.2.p.4">An UNSUBSCRIBE response message MUST NOT contain a Session Signaling Operation TLV.  The Session Signaling Operation TLV is NOT copied from the UNSUBSCRIBE request.</p>
<p id="rfc.section.6.4.2.p.5">In the UNSUBSCRIBE response the RCODE indicates whether or not the unsubscribe request was successful. Supported RCODEs are as follows:</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
  <caption>UNSUBSCRIBE Response codes</caption>
  <thead>
    <tr>
      <th class="left">Mnemonic</th>
      <th class="center">Value</th>
      <th class="left">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="left">NOERROR</td>
      <td class="center">0</td>
      <td class="left">UNSUBSCRIBE successful.</td>
    </tr>
    <tr>
      <td class="left">FORMERR</td>
      <td class="center">1</td>
      <td class="left">Server failed to process request due to a malformed request.</td>
    </tr>
    <tr>
      <td class="left">NXDOMAIN</td>
      <td class="center">3</td>
      <td class="left">Specified subscription does not exist.</td>
    </tr>
    <tr>
      <td class="left">NOTIMP</td>
      <td class="center">4</td>
      <td class="left">Server does not recognize DNS Session Signaling Opcode.</td>
    </tr>
    <tr>
      <td class="left">SSOPNOTIMP</td>
      <td class="center">11</td>
      <td class="left">UNSUBSCRIBE operation not supported.</td>
    </tr>
  </tbody>
</table>
<p id="rfc.section.6.4.2.p.6">This document specifies only these RCODE values for UNSUBSCRIBE Responses. Servers sending UNSUBSCRIBE Responses SHOULD use one of these values. However, future circumstances may create situations where other RCODE values are appropriate in UNSUBSCRIBE Responses, so clients MUST be prepared to accept UNSUBSCRIBE Responses with any RCODE value.</p>
<p id="rfc.section.6.4.2.p.7">Having being successfully revoked with a correctly-formatted UNSUBSCRIBE message (resulting in a response with RCODE NOERROR) the previously referenced subscription is no longer active and the server MAY discard the state associated with it immediately, or later, at the server's discretion.</p>
<p id="rfc.section.6.4.2.p.8">Nonzero RCODE values signal some kind of error.</p>
<p id="rfc.section.6.4.2.p.9">RCODE value FORMERR indicates a message format error.</p>
<p id="rfc.section.6.4.2.p.10">RCODE value NXDOMAIN indicates a MESSAGE ID that does not correspond to any active subscription.</p>
<p id="rfc.section.6.4.2.p.11">RCODE values NOTIMP and SSOPNOTIMP should not occur in practice.</p>
<p id="rfc.section.6.4.2.p.12">A server would only generate NOTIMP if it did not support Session Signaling, and if the server does not support Session Signaling then it should not be possible for a client to have an active subscription to cancel.</p>
<p id="rfc.section.6.4.2.p.13">Similarly, a server would only generate SSOPNOTIMP if it did not support Push Notifications, and if the server does not support Push Notifications then it should not be possible for a client to have an active subscription to cancel.</p>
<p id="rfc.section.6.4.2.p.14">Nonzero RCODE values other than NXDOMAIN indicate a serious problem with the client. After sending an error response other than NXDOMAIN, the server SHOULD send a DNS Session Signaling Retry Delay Operation TLV and then close the TCP connection, as described in the <a href="#SessSig">DNS Session Signaling specification</a> <cite title="NONE">[SessSig]</cite>.</p>
<h1 id="rfc.section.6.5"><a href="#rfc.section.6.5">6.5.</a> DNS Push Notification RECONFIRM</h1>
<p id="rfc.section.6.5.p.1">Sometimes, particularly when used with a <a href="#DisProx">Discovery Proxy</a> <cite title="NONE">[DisProx]</cite>, a DNS Zone may contain stale data. When a client encounters data that it believe may be stale (e.g., an SRV record referencing a target host+port that is not responding to connection requests) the client can send a RECONFIRM request to ask the server to re-verify that the data is still valid. For a Discovery Proxy, this causes it to issue new Multicast DNS requests to ascertain whether the target device is still present. For other types of DNS server, the RECONFIRM operation is currently undefined, and SHOULD result in a NOERROR response, but otherwise need not cause any action to occur. Frequent RECONFIRM operations may be a sign of network unreliability, or some kind of misconfiguration, so RECONFIRM operations MAY be logged or otherwise communicated to a human administrator to assist in detecting, and remedying, such network problems.</p>
<p id="rfc.section.6.5.p.2">If, after receiving a valid RECONFIRM request, the server determines that the disputed records are in fact no longer valid, then subsequent DNS PUSH Messages will be generated to inform interested clients. Thus, one client discovering that a previously-advertised device (like a network printer) is no longer present has the side effect of informing all other interested clients that the device in question is now gone.</p>
<h1 id="rfc.section.6.5.1"><a href="#rfc.section.6.5.1">6.5.1.</a> RECONFIRM Request</h1>
<p id="rfc.section.6.5.1.p.1">A RECONFIRM request message begins with the standard <a href="#SessSig">DNS Session Signaling 12-byte header</a> <cite title="NONE">[SessSig]</cite>, followed by the RECONFIRM TLV.  A RECONFIRM request message is illustrated below:</p>
<div id="rfc.figure.4"/>
<div id="reconfirm_req"/>
<pre>
                                1  1  1  1  1  1
  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                  MESSAGE ID                   |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|QR|  Opcode   |         Z          |   RCODE   |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|             QDCOUNT (MUST BE ZERO)            |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|             ANCOUNT (MUST BE ZERO)            |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|             NSCOUNT (MUST BE ZERO)            |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|             ARCOUNT (MUST BE ZERO)            |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|   SSOP-TYPE = RECONFIRM (tentatively 0x43)    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|  SSOP-LENGTH (number of octets in SSOP-DATA)  |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+  \
\                     NAME                      \   \
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    |
|                     TYPE                      |    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    |
|                     CLASS                     |     &gt; SSOP-DATA
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    |
|                     RDLEN                     |    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    |
\                     RDATA                     \   /
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+  /</pre>
<p class="figure">Figure 4</p>
<p id="rfc.section.6.5.1.p.2">The MESSAGE ID field MUST be set to a unique value, that the client is not using for any other active operation on this connection. For the purposes here, a MESSAGE ID is in use on this connection if the client has used it in a request for which it has not yet received a response, or if the client has used it for a subscription which it has not yet cancelled using UNSUBSCRIBE. In the RECONFIRM response the server MUST echo back the MESSAGE ID value unchanged.</p>
<p id="rfc.section.6.5.1.p.3">The other header fields MUST be set as described in the <a href="#SessSig">DNS Session Signaling specification</a> <cite title="NONE">[SessSig]</cite>.  The DNS Opcode is the Session Signaling Opcode (tentatively 6).  The four count fields MUST be empty, and the corresponding four sections MUST be empty (i.e., absent).</p>
<p id="rfc.section.6.5.1.p.4">The SSOP-TYPE is RECONFIRM (tentatively 0x43).  The SSOP-LENGTH is the length of the data that follows, which specifies the name, type, class, and content of the record being disputed.</p>
<p id="rfc.section.6.5.1.p.5">The SSOP-DATA for a RECONFIRM request MUST contain exactly one record.  The SSOP-DATA for a RECONFIRM request has no count field to specify more than one record.  Since RECONFIRM requests are sent over TCP, multiple RECONFIRM request messages can be concatenated in a single TCP stream and packed efficiently into TCP segments.</p>
<p id="rfc.section.6.5.1.p.6">TYPE MUST NOT be the value ANY (255) and CLASS MUST NOT be the value ANY (255).</p>
<p id="rfc.section.6.5.1.p.7">DNS wildcarding is not supported. That is, a wildcard ("*") in a RECONFIRM message matches only a literal wildcard character ("*") in the zone, and nothing else.</p>
<p id="rfc.section.6.5.1.p.8">Aliasing is not supported. That is, a CNAME in a RECONFIRM message matches only a literal CNAME record in the zone, and nothing else.</p>
<h1 id="rfc.section.6.5.2"><a href="#rfc.section.6.5.2">6.5.2.</a> RECONFIRM Response</h1>
<p id="rfc.section.6.5.2.p.1">Each RECONFIRM request generates exactly one RECONFIRM response from the server.</p>
<p id="rfc.section.6.5.2.p.2">A RECONFIRM response message begins with the standard <a href="#SessSig">DNS Session Signaling 12-byte header</a> <cite title="NONE">[SessSig]</cite>, possibly followed by one or more optional Modifier TLVs, such as a Retry Delay Modifier TLV.</p>
<p id="rfc.section.6.5.2.p.3">The MESSAGE ID field MUST echo the value given in the ID field of the RECONFIRM request.  This is how the client knows which request is being responded to.</p>
<p id="rfc.section.6.5.2.p.4">A RECONFIRM response message MUST NOT contain a Session Signaling Operation TLV.  The Session Signaling Operation TLV is NOT copied from the RECONFIRM request.</p>
<p id="rfc.section.6.5.2.p.5">In the RECONFIRM response the RCODE confirms receipt of the reconfirmation request. Supported RCODEs are as follows:</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
  <caption>RECONFIRM Response codes</caption>
  <thead>
    <tr>
      <th class="left">Mnemonic</th>
      <th class="center">Value</th>
      <th class="left">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="left">NOERROR</td>
      <td class="center">0</td>
      <td class="left">RECONFIRM accepted.</td>
    </tr>
    <tr>
      <td class="left">FORMERR</td>
      <td class="center">1</td>
      <td class="left">Server failed to process request due to a malformed request.</td>
    </tr>
    <tr>
      <td class="left">SERVFAIL</td>
      <td class="center">2</td>
      <td class="left">Server failed to process request due to a problem with the server.</td>
    </tr>
    <tr>
      <td class="left">NXDOMAIN</td>
      <td class="center">3</td>
      <td class="left">NOT APPLICABLE. DNS Push Notification servers MUST NOT return NXDOMAIN errors in response to RECONFIRM requests.</td>
    </tr>
    <tr>
      <td class="left">NOTIMP</td>
      <td class="center">4</td>
      <td class="left">Server does not recognize DNS Session Signaling Opcode.</td>
    </tr>
    <tr>
      <td class="left">REFUSED</td>
      <td class="center">5</td>
      <td class="left">Server refuses to process request for policy or security reasons.</td>
    </tr>
    <tr>
      <td class="left">NOTAUTH</td>
      <td class="center">9</td>
      <td class="left">Server is not authoritative for the requested name.</td>
    </tr>
    <tr>
      <td class="left">SSOPNOTIMP</td>
      <td class="center">11</td>
      <td class="left">RECONFIRM operation not supported.</td>
    </tr>
  </tbody>
</table>
<p id="rfc.section.6.5.2.p.6">This document specifies only these RCODE values for RECONFIRM Responses. Servers sending RECONFIRM Responses SHOULD use one of these values. However, future circumstances may create situations where other RCODE values are appropriate in RECONFIRM Responses, so clients MUST be prepared to accept RECONFIRM Responses with any RCODE value.</p>
<p id="rfc.section.6.5.2.p.7">Nonzero RCODE values signal some kind of error.</p>
<p id="rfc.section.6.5.2.p.8">RCODE value FORMERR indicates a message format error, for example TYPE or CLASS being ANY (255).</p>
<p id="rfc.section.6.5.2.p.9">RCODE value SERVFAIL indicates that the server has exhausted its resources or other serious problem occurred.</p>
<p id="rfc.section.6.5.2.p.10">RCODE values NOTIMP indicates that the server does not support Session Signaling, and Session Signaling is required for RECONFIRM requests.</p>
<p id="rfc.section.6.5.2.p.11">RCODE value REFUSED indicates that the server supports RECONFIRM requests but is currently not configured to accept them from this client.</p>
<p id="rfc.section.6.5.2.p.12">RCODE value NOTAUTH indicates that the server is not authoritative for the requested name, and can do nothing to remedy the apparent error. Note that there may be future cases in which a server is able to pass on the RECONFIRM request to the ultimate source of the information, and in these cases the server should return NOERROR.</p>
<p id="rfc.section.6.5.2.p.13">RCODE value SSOPNOTIMP indicates that the server does not support RECONFIRM requests.</p>
<p id="rfc.section.6.5.2.p.14">Similarly, a server would only generate SSOPNOTIMP if it did not support Push Notifications, and if the server does not support Push Notifications then it should not be possible for a client to have an active subscription to cancel.</p>
<p id="rfc.section.6.5.2.p.15">Nonzero RCODE values SERVFAIL, REFUSED and SSOPNOTIMP are benign from the client's point of view. The client may log them to aid in debugging, but otherwise they require no special action.</p>
<p id="rfc.section.6.5.2.p.16">Nonzero RCODE values other than these three indicate a serious problem with the client. After sending an error response other than one of these three, the server SHOULD send a DNS Session Signaling Retry Delay Operation TLV and then close the TCP connection, as described in the <a href="#SessSig">DNS Session Signaling specification</a> <cite title="NONE">[SessSig]</cite>.</p>
<h1 id="rfc.section.6.6"><a href="#rfc.section.6.6">6.6.</a> Client-Initiated Termination</h1>
<p id="rfc.section.6.6.p.1">An individual subscription is terminated by sending an UNSUBSCRIBE TLV for that specific subscription, or all subscriptions can be cancelled at once by the client closing the connection. When a client terminates an individual subscription (via UNSUBSCRIBE) or all subscriptions on that connection (by closing the connection) it is signaling to the server that it is longer interested in receiving those particular updates. It is informing the server that the server may release any state information it has been keeping with regards to these particular subscriptions.</p>
<p id="rfc.section.6.6.p.2">After terminating its last subscription on a connection via UNSUBSCRIBE, a client MAY close the connection immediately, or it may keep it open if it anticipates performing further operations on that connection in the future. If a client wishes to keep an idle connection open, it MUST respect the maximum idle time required by the server <a href="#SessSig">[SessSig]</a>.</p>
<p id="rfc.section.6.6.p.3">If a client plans to terminate one or more subscriptions on a connection and doesn't intend to keep that connection open, then as an efficiency optimization it MAY instead choose to simply close the connection, which implicitly terminates all subscriptions on that connection. This may occur because the client computer is being shut down, is going to sleep, the application requiring the subscriptions has terminated, or simply because the last active subscription on that connection has been cancelled.</p>
<p id="rfc.section.6.6.p.4">When closing a connection, a client will generally do an abortive disconnect, sending a TCP RST. This immediately discards all remaining inbound and outbound data, which is appropriate if the client no longer has any interest in this data. In the BSD Sockets API, sending a TCP RST is achieved by setting the SO_LINGER option with a time of 0 seconds and then closing the socket.</p>
<p id="rfc.section.6.6.p.5">If a client has performed operations on this connection that it would not want lost (like DNS updates) then the client SHOULD do an orderly disconnect, sending a TCP FIN. In the BSD Sockets API, sending a TCP FIN is achieved by calling "shutdown(s,SHUT_WR)" and keeping the socket open until all remaining data has been read from it.</p>
<h1 id="rfc.section.7"><a href="#rfc.section.7">7.</a> <a href="#Security" id="Security">Security Considerations</a></h1>
<p id="rfc.section.7.p.1">The Strict Privacy Usage Profile for DNS over TLS is strongly recommended for DNS Push Notifications as defined in <a href="#I-D.ietf-dprive-dtls-and-tls-profiles">Authentication and (D)TLS Profile for DNS-over-(D)TLS</a> <cite title="NONE">[I-D.ietf-dprive-dtls-and-tls-profiles]</cite>. The Opportunistic Privacy Usage Profile is permissible as a way to support incremental deployment of security capabilities. Cleartext connections for DNS Push Notifications are not permissible.</p>
<p id="rfc.section.7.p.2">DNSSEC is RECOMMENDED for the authentication of DNS Push Notification servers. TLS alone does not provide complete security. TLS certificate verification can provide reasonable assurance that the client is really talking to the server associated with the desired host name, but since the desired host name is learned via a DNS SRV query, if the SRV query is subverted then the client may have a secure connection to a rogue server. DNSSEC can provided added confidence that the SRV query has not been subverted.</p>
<h1 id="rfc.section.7.1"><a href="#rfc.section.7.1">7.1.</a> Security Services</h1>
<p id="rfc.section.7.1.p.1">It is the goal of using TLS to provide the following security services: </p>

<dl>
  <dt>Confidentiality:</dt>
  <dd style="margin-left: 8">All application-layer communication is encrypted with the goal that no party should be able to decrypt it except the intended receiver.</dd>
  <dt>Data integrity protection:</dt>
  <dd style="margin-left: 8">Any changes made to the communication in transit are detectable by the receiver.</dd>
  <dt>Authentication:</dt>
  <dd style="margin-left: 8">An end-point of the TLS communication is authenticated as the intended entity to communicate with.</dd>
</dl>

<p> </p>
<p id="rfc.section.7.1.p.2">Deployment recommendations on the appropriate key lengths and cypher suites are beyond the scope of this document. Please refer to <a href="#RFC7525">TLS Recommendations</a> <cite title="NONE">[RFC7525]</cite> for the best current practices. Keep in mind that best practices only exist for a snapshot in time and recommendations will continue to change. Updated versions or errata may exist for these recommendations.</p>
<h1 id="rfc.section.7.2"><a href="#rfc.section.7.2">7.2.</a> <a href="#tls_name_auth" id="tls_name_auth">TLS Name Authentication</a></h1>
<p id="rfc.section.7.2.p.1">As described in <a href="#discovery">Section 6.1</a>, the client discovers the DNS Push Notification server using an SRV lookup for the record name <samp>_dns&#8209;push&#8209;tls._tcp.&lt;zone&gt;</samp>. The server connection endpoint SHOULD then be authenticated using DANE TLSA records for the associated SRV record. This associates the target's name and port number with a trusted TLS certificate <a href="#RFC7673">[RFC7673]</a>. This procedure uses the TLS Sever Name Indication (SNI) extension <a href="#RFC6066">[RFC6066]</a> to inform the server of the name the client has authenticated through the use of TLSA records. Therefore, if the SRV record passes DNSSEC validation and a TLSA record matching the target name is useable, an SNI extension must be used for the target name to ensure the client is connecting to the server it has authenticated. If the target name does not have a usable TLSA record, then the use of the SNI extension is optional.</p>
<p id="rfc.section.7.2.p.2">See <a href="#I-D.ietf-dprive-dtls-and-tls-profiles">Authentication and (D)TLS Profile for DNS-over-(D)TLS</a> <cite title="NONE">[I-D.ietf-dprive-dtls-and-tls-profiles]</cite> for more information on authenticating domain names. Also note that a DNS Push server is an authoritative server and a DNS Push client is a standard DNS client. While the terminology in <a href="#I-D.ietf-dprive-dtls-and-tls-profiles">Authentication and (D)TLS Profile for DNS-over-(D)TLS</a> <cite title="NONE">[I-D.ietf-dprive-dtls-and-tls-profiles]</cite> explicitly states it does not apply to authoritative servers, it does in this case apply to DNS Push Notification clients and servers.</p>
<h1 id="rfc.section.7.3"><a href="#rfc.section.7.3">7.3.</a> TLS Compression</h1>
<p id="rfc.section.7.3.p.1">In order to reduce the chances of compression-related attacks, TLS-level compression SHOULD be disabled when using TLS versions 1.2 and earlier. In the draft version of <a href="#I-D.ietf-tls-tls13">TLS 1.3</a> <cite title="NONE">[I-D.ietf-tls-tls13]</cite>, TLS-level compression has been removed completely.</p>
<h1 id="rfc.section.7.4"><a href="#rfc.section.7.4">7.4.</a> TLS Session Resumption</h1>
<p id="rfc.section.7.4.p.1">TLS Session Resumption is permissible on DNS Push Notification servers. The server may keep TLS state with Session IDs <a href="#RFC5246">[RFC5246]</a> or operate in stateless mode by sending a Session Ticket <a href="#RFC5077">[RFC5077]</a> to the client for it to store. However, once the connection is closed, any existing subscriptions will be dropped. When the TLS session is resumed, the DNS Push Notification server will not have any subscription state and will proceed as with any other new connection. Use of TLS Session Resumption allows a new TLS connection to be set up more quickly, but the client will still have to recreate any desired subscriptions.</p>
<h1 id="rfc.section.8"><a href="#rfc.section.8">8.</a> <a href="#IANA" id="IANA">IANA Considerations</a></h1>
<p id="rfc.section.8.p.1">This document defines the service name: <samp>_dns&#8209;push&#8209;tls._tcp</samp>.<br/> It is only applicable for the TCP protocol.<br/> This name is to be published in the IANA Service Name Registry <a href="#RFC6335">[RFC6335]</a><a href="#SN">[SN]</a>.</p>
<p id="rfc.section.8.p.2">This document defines four DNS Session Signaling TLV types: SUBSCRIBE with (tentative) value 0x40 (64), PUSH with (tentative) value 0x41 (65), UNSUBSCRIBE with (tentative) value 0x42 (66), and RECONFIRM with (tentative) value 0x43 (67).</p>
<h1 id="rfc.section.9"><a href="#rfc.section.9">9.</a> <a href="#Acknowledgements" id="Acknowledgements">Acknowledgements</a></h1>
<p id="rfc.section.9.p.1">The authors would like to thank Kiren Sekar and Marc Krochmal for previous work completed in this field.</p>
<p id="rfc.section.9.p.2">This draft has been improved due to comments from Ran Atkinson, Tim Chown, Mark Delany, Ralph Droms, Bernie Volz, Jan Komissar, Manju Shankar Rao, Markus Stenberg, Dave Thaler, and Soraia Zlatkovic.</p>
<h1 id="rfc.references"><a href="#rfc.references">10.</a> References</h1>
<h1 id="rfc.references.1"><a href="#rfc.references.1">10.1.</a> Normative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</b>
      </td>
      <td class="top"><a>Rescorla, E.</a>, "<a href="http://tools.ietf.org/html/draft-ietf-tls-tls13-20">The Transport Layer Security (TLS) Protocol Version 1.3</a>", Internet-Draft draft-ietf-tls-tls13-20, April 2017.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC0768">[RFC0768]</b>
      </td>
      <td class="top"><a>Postel, J.</a>, "<a href="http://tools.ietf.org/html/rfc768">User Datagram Protocol</a>", STD 6, RFC 768, DOI 10.17487/RFC0768, August 1980.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC0793">[RFC0793]</b>
      </td>
      <td class="top"><a>Postel, J.</a>, "<a href="http://tools.ietf.org/html/rfc793">Transmission Control Protocol</a>", STD 7, RFC 793, DOI 10.17487/RFC0793, September 1981.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC1034">[RFC1034]</b>
      </td>
      <td class="top"><a>Mockapetris, P.</a>, "<a href="http://tools.ietf.org/html/rfc1034">Domain names - concepts and facilities</a>", STD 13, RFC 1034, DOI 10.17487/RFC1034, November 1987.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC1035">[RFC1035]</b>
      </td>
      <td class="top"><a>Mockapetris, P.</a>, "<a href="http://tools.ietf.org/html/rfc1035">Domain names - implementation and specification</a>", STD 13, RFC 1035, DOI 10.17487/RFC1035, November 1987.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC1123">[RFC1123]</b>
      </td>
      <td class="top"><a>Braden, R.</a>, "<a href="http://tools.ietf.org/html/rfc1123">Requirements for Internet Hosts - Application and Support</a>", STD 3, RFC 1123, DOI 10.17487/RFC1123, October 1989.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2119">[RFC2119]</b>
      </td>
      <td class="top"><a>Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2136">[RFC2136]</b>
      </td>
      <td class="top"><a>Vixie, P.</a>, <a>Thomson, S.</a>, <a>Rekhter, Y.</a> and <a>J. Bound</a>, "<a href="http://tools.ietf.org/html/rfc2136">Dynamic Updates in the Domain Name System (DNS UPDATE)</a>", RFC 2136, DOI 10.17487/RFC2136, April 1997.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2782">[RFC2782]</b>
      </td>
      <td class="top"><a>Gulbrandsen, A.</a>, <a>Vixie, P.</a> and <a>L. Esibov</a>, "<a href="http://tools.ietf.org/html/rfc2782">A DNS RR for specifying the location of services (DNS SRV)</a>", RFC 2782, DOI 10.17487/RFC2782, February 2000.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5246">[RFC5246]</b>
      </td>
      <td class="top"><a>Dierks, T.</a> and <a>E. Rescorla</a>, "<a href="http://tools.ietf.org/html/rfc5246">The Transport Layer Security (TLS) Protocol Version 1.2</a>", RFC 5246, DOI 10.17487/RFC5246, August 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6066">[RFC6066]</b>
      </td>
      <td class="top"><a>Eastlake 3rd, D.</a>, "<a href="http://tools.ietf.org/html/rfc6066">Transport Layer Security (TLS) Extensions: Extension Definitions</a>", RFC 6066, DOI 10.17487/RFC6066, January 2011.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6335">[RFC6335]</b>
      </td>
      <td class="top"><a>Cotton, M.</a>, <a>Eggert, L.</a>, <a>Touch, J.</a>, <a>Westerlund, M.</a> and <a>S. Cheshire</a>, "<a href="http://tools.ietf.org/html/rfc6335">Internet Assigned Numbers Authority (IANA) Procedures for the Management of the Service Name and Transport Protocol Port Number Registry</a>", BCP 165, RFC 6335, DOI 10.17487/RFC6335, August 2011.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6895">[RFC6895]</b>
      </td>
      <td class="top"><a>Eastlake 3rd, D.</a>, "<a href="http://tools.ietf.org/html/rfc6895">Domain Name System (DNS) IANA Considerations</a>", BCP 42, RFC 6895, DOI 10.17487/RFC6895, April 2013.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7673">[RFC7673]</b>
      </td>
      <td class="top"><a>Finch, T.</a>, <a>Miller, M.</a> and <a>P. Saint-Andre</a>, "<a href="http://tools.ietf.org/html/rfc7673">Using DNS-Based Authentication of Named Entities (DANE) TLSA Records with SRV Records</a>", RFC 7673, DOI 10.17487/RFC7673, October 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7766">[RFC7766]</b>
      </td>
      <td class="top"><a>Dickinson, J.</a>, <a>Dickinson, S.</a>, <a>Bellis, R.</a>, <a>Mankin, A.</a> and <a>D. Wessels</a>, "<a href="http://tools.ietf.org/html/rfc7766">DNS Transport over TCP - Implementation Requirements</a>", RFC 7766, DOI 10.17487/RFC7766, March 2016.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="SessSig">[SessSig]</b>
      </td>
      <td class="top"><a>Bellis, R.</a>, <a>Cheshire, S.</a>, <a>Dickinson, J.</a>, <a>Dickinson, S.</a>, <a>Mankin, A.</a> and <a>T. Pusateri</a>, <a href="http://tools.ietf.org/html/draft-ietf-dnsop-session-signal-02">DNS Session Signaling</a>", Internet-Draft draft-ietf-dnsop-session-signal-02, March 2017.</td>
    </tr>
    <tr><td class="reference"><b id="SN">[SN]</b></td><td class="top"><a href="http://www.iana.org/assignments/service-names-port-numbers/">Service Name and Transport Protocol Port Number Registry</a>"</td>, "</tr>
  </tbody>
</table>
<h1 id="rfc.references.2"><a href="#rfc.references.2">10.2.</a> Informative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="DisProx">[DisProx]</b>
      </td>
      <td class="top"><a>Cheshire, S.</a>, "<a href="http://tools.ietf.org/html/draft-ietf-dnssd-hybrid-06">Hybrid Unicast/Multicast DNS-Based Service Discovery</a>", Internet-Draft draft-ietf-dnssd-hybrid-06, March 2017.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.dukkipati-tcpm-tcp-loss-probe">[I-D.dukkipati-tcpm-tcp-loss-probe]</b>
      </td>
      <td class="top"><a>Dukkipati, N.</a>, <a>Cardwell, N.</a>, <a>Cheng, Y.</a> and <a>M. Mathis</a>, "<a href="http://tools.ietf.org/html/draft-dukkipati-tcpm-tcp-loss-probe-01">Tail Loss Probe (TLP): An Algorithm for Fast Recovery of Tail Losses</a>", Internet-Draft draft-dukkipati-tcpm-tcp-loss-probe-01, February 2013.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-dprive-dtls-and-tls-profiles">[I-D.ietf-dprive-dtls-and-tls-profiles]</b>
      </td>
      <td class="top"><a>Dickinson, S.</a>, <a>Gillmor, D.</a> and <a>T. Reddy</a>, "<a href="http://tools.ietf.org/html/draft-ietf-dprive-dtls-and-tls-profiles-09">Authentication and (D)TLS Profile for DNS-over-(D)TLS</a>", Internet-Draft draft-ietf-dprive-dtls-and-tls-profiles-09, April 2017.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.sekar-dns-llq">[I-D.sekar-dns-llq]</b>
      </td>
      <td class="top"><a>Sekar, K.</a>, "<a href="http://tools.ietf.org/html/draft-sekar-dns-llq-01">DNS Long-Lived Queries</a>", Internet-Draft draft-sekar-dns-llq-01, August 2006.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="IPJ.9-4-TCPSYN">[IPJ.9-4-TCPSYN]</b>
      </td>
      <td class="top"><a href="mailto:weddy@grc.nasa.gov" title="Verizon Federal Network Systems">Eddy, W.</a>, <a>Defenses Against TCP SYN Flooding Attacks</a>", The Internet Protocol Journal, Cisco Systems, Volume 9, Number 4, December 2006.</td>
    </tr>
    <tr><td class="reference"><b id="obs">[obs]</b></td><td class="top"><a href="https://en.wikipedia.org/wiki/Observer_pattern">Observer Pattern</a>"</td>, "</tr>
    <tr>
      <td class="reference">
        <b id="RFC2308">[RFC2308]</b>
      </td>
      <td class="top"><a>Andrews, M.</a>, "<a href="http://tools.ietf.org/html/rfc2308">Negative Caching of DNS Queries (DNS NCACHE)</a>", RFC 2308, DOI 10.17487/RFC2308, March 1998.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4287">[RFC4287]</b>
      </td>
      <td class="top"><a>Nottingham, M.</a> and <a>R. Sayre</a>, "<a href="http://tools.ietf.org/html/rfc4287">The Atom Syndication Format</a>", RFC 4287, DOI 10.17487/RFC4287, December 2005.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4953">[RFC4953]</b>
      </td>
      <td class="top"><a>Touch, J.</a>, "<a href="http://tools.ietf.org/html/rfc4953">Defending TCP Against Spoofing Attacks</a>", RFC 4953, DOI 10.17487/RFC4953, July 2007.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5077">[RFC5077]</b>
      </td>
      <td class="top"><a>Salowey, J.</a>, <a>Zhou, H.</a>, <a>Eronen, P.</a> and <a>H. Tschofenig</a>, "<a href="http://tools.ietf.org/html/rfc5077">Transport Layer Security (TLS) Session Resumption without Server-Side State</a>", RFC 5077, DOI 10.17487/RFC5077, January 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6281">[RFC6281]</b>
      </td>
      <td class="top"><a>Cheshire, S.</a>, <a>Zhu, Z.</a>, <a>Wakikawa, R.</a> and <a>L. Zhang</a>, "<a href="http://tools.ietf.org/html/rfc6281">Understanding Apple's Back to My Mac (BTMM) Service</a>", RFC 6281, DOI 10.17487/RFC6281, June 2011.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6762">[RFC6762]</b>
      </td>
      <td class="top"><a>Cheshire, S.</a> and <a>M. Krochmal</a>, "<a href="http://tools.ietf.org/html/rfc6762">Multicast DNS</a>", RFC 6762, DOI 10.17487/RFC6762, February 2013.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6763">[RFC6763]</b>
      </td>
      <td class="top"><a>Cheshire, S.</a> and <a>M. Krochmal</a>, "<a href="http://tools.ietf.org/html/rfc6763">DNS-Based Service Discovery</a>", RFC 6763, DOI 10.17487/RFC6763, February 2013.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6824">[RFC6824]</b>
      </td>
      <td class="top"><a>Ford, A.</a>, <a>Raiciu, C.</a>, <a>Handley, M.</a> and <a>O. Bonaventure</a>, "<a href="http://tools.ietf.org/html/rfc6824">TCP Extensions for Multipath Operation with Multiple Addresses</a>", RFC 6824, DOI 10.17487/RFC6824, January 2013.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7413">[RFC7413]</b>
      </td>
      <td class="top"><a>Cheng, Y.</a>, <a>Chu, J.</a>, <a>Radhakrishnan, S.</a> and <a>A. Jain</a>, "<a href="http://tools.ietf.org/html/rfc7413">TCP Fast Open</a>", RFC 7413, DOI 10.17487/RFC7413, December 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7525">[RFC7525]</b>
      </td>
      <td class="top"><a>Sheffer, Y.</a>, <a>Holz, R.</a> and <a>P. Saint-Andre</a>, "<a href="http://tools.ietf.org/html/rfc7525">Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)</a>", BCP 195, RFC 7525, DOI 10.17487/RFC7525, May 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7719">[RFC7719]</b>
      </td>
      <td class="top"><a>Hoffman, P.</a>, <a>Sullivan, A.</a> and <a>K. Fujiwara</a>, "<a href="http://tools.ietf.org/html/rfc7719">DNS Terminology</a>", RFC 7719, DOI 10.17487/RFC7719, December 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7858">[RFC7858]</b>
      </td>
      <td class="top"><a>Hu, Z.</a>, <a>Zhu, L.</a>, <a>Heidemann, J.</a>, <a>Mankin, A.</a>, <a>Wessels, D.</a> and <a>P. Hoffman</a>, "<a href="http://tools.ietf.org/html/rfc7858">Specification for DNS over Transport Layer Security (TLS)</a>", RFC 7858, DOI 10.17487/RFC7858, May 2016.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="XEP0060">[XEP0060]</b>
      </td>
      <td class="top"><a>Millard, P.</a>, <a href="mailto:peter@andyet.net">Saint-Andre, P.</a> and <a href="mailto:ralphm@ik.nu">R. Meijer</a>, "<a>Publish-Subscribe</a>", XSF XEP 0060, July 2010.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Authors' Addresses</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Tom Pusateri</span> 
	  <span class="n hidden">
		<span class="family-name">Pusateri</span>
	  </span>
	</span>
	<span class="org vcardline">Seeking affiliation</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality">Hilton Head Island</span>,  
		<span class="region">SC</span> 
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">USA</span>
	</span>
	<span class="vcardline">Phone: +1 843 473 7394</span>

<span class="vcardline">EMail: <a href="mailto:pusateri@bangj.com">pusateri@bangj.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Stuart Cheshire</span> 
	  <span class="n hidden">
		<span class="family-name">Cheshire</span>
	  </span>
	</span>
	<span class="org vcardline">Apple Inc.</span>
	<span class="adr">
	  <span class="vcardline">1 Infinite Loop</span>

	  <span class="vcardline">
		<span class="locality">Cupertino</span>,  
		<span class="region">CA</span> 
		<span class="code">95014</span>
	  </span>
	  <span class="country-name vcardline">USA</span>
	</span>
	<span class="vcardline">Phone: +1 408 974 3207</span>

<span class="vcardline">EMail: <a href="mailto:cheshire@apple.com">cheshire@apple.com</a></span>

  </address>
</div>

</body>
</html>
